#-*- coding:utf-8 -*-
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class RpcLibraFErrorType:
  RPC_UNDEFINED_ERROR = 268435455
  RPC_SENSOR_CONNECT_ERROR = 268435457
  RPC_SENSOR_NUMBER_ERROR = 268435458
  RPC_SENSOR_NOT_USB3_ERROR = 268435459
  RPC_SENSOR_START_ERROR = 268435460
  RPC_SENSOR_GET_STATUS_ERROR = 268435461
  RPC_SENSOR_SET_STATUS_ERROR = 268435462
  RPC_SENSOR_GET_IMG_DATA_ERROR = 268435463
  RPC_SENSOR_READ_NONSTART_CAMERA_ERROR = 268435464
  RPC_SENSOR_GET_IMG_DATA_TIMEOUT_ERROR = 268435465
  RPC_SENSOR_XU_ERROR = 268435466
  RPC_SENSOR_OCCLUSION_ERROR = 268435467
  RPC_CALIBRATION_BUSY = 805306369
  RPC_CATCHALL_BUSY = 805306370
  RPC_UNDEFINED_BUSY = 805306371
  RPC_MOTOR_POWER_ERROR = 536870913
  RPC_MOTOR_OCCLUSION_ERROR = 536870914
  RPC_MOTOR_ALGO_ERROR = 536870915
  RPC_MOTOR_INVALID_ANGLE = 536870916
  RPC_INPUT_ERROR = 1
  RPC_OPERATION_OCCLUSION_ERROR = 2

  _VALUES_TO_NAMES = {
    268435455: "RPC_UNDEFINED_ERROR",
    268435457: "RPC_SENSOR_CONNECT_ERROR",
    268435458: "RPC_SENSOR_NUMBER_ERROR",
    268435459: "RPC_SENSOR_NOT_USB3_ERROR",
    268435460: "RPC_SENSOR_START_ERROR",
    268435461: "RPC_SENSOR_GET_STATUS_ERROR",
    268435462: "RPC_SENSOR_SET_STATUS_ERROR",
    268435463: "RPC_SENSOR_GET_IMG_DATA_ERROR",
    268435464: "RPC_SENSOR_READ_NONSTART_CAMERA_ERROR",
    268435465: "RPC_SENSOR_GET_IMG_DATA_TIMEOUT_ERROR",
    268435466: "RPC_SENSOR_XU_ERROR",
    268435467: "RPC_SENSOR_OCCLUSION_ERROR",
    805306369: "RPC_CALIBRATION_BUSY",
    805306370: "RPC_CATCHALL_BUSY",
    805306371: "RPC_UNDEFINED_BUSY",
    536870913: "RPC_MOTOR_POWER_ERROR",
    536870914: "RPC_MOTOR_OCCLUSION_ERROR",
    536870915: "RPC_MOTOR_ALGO_ERROR",
    536870916: "RPC_MOTOR_INVALID_ANGLE",
    1: "RPC_INPUT_ERROR",
    2: "RPC_OPERATION_OCCLUSION_ERROR",
  }

  _NAMES_TO_VALUES = {
    "RPC_UNDEFINED_ERROR": 268435455,
    "RPC_SENSOR_CONNECT_ERROR": 268435457,
    "RPC_SENSOR_NUMBER_ERROR": 268435458,
    "RPC_SENSOR_NOT_USB3_ERROR": 268435459,
    "RPC_SENSOR_START_ERROR": 268435460,
    "RPC_SENSOR_GET_STATUS_ERROR": 268435461,
    "RPC_SENSOR_SET_STATUS_ERROR": 268435462,
    "RPC_SENSOR_GET_IMG_DATA_ERROR": 268435463,
    "RPC_SENSOR_READ_NONSTART_CAMERA_ERROR": 268435464,
    "RPC_SENSOR_GET_IMG_DATA_TIMEOUT_ERROR": 268435465,
    "RPC_SENSOR_XU_ERROR": 268435466,
    "RPC_SENSOR_OCCLUSION_ERROR": 268435467,
    "RPC_CALIBRATION_BUSY": 805306369,
    "RPC_CATCHALL_BUSY": 805306370,
    "RPC_UNDEFINED_BUSY": 805306371,
    "RPC_MOTOR_POWER_ERROR": 536870913,
    "RPC_MOTOR_OCCLUSION_ERROR": 536870914,
    "RPC_MOTOR_ALGO_ERROR": 536870915,
    "RPC_MOTOR_INVALID_ANGLE": 536870916,
    "RPC_INPUT_ERROR": 1,
    "RPC_OPERATION_OCCLUSION_ERROR": 2,
  }

class RpcSensorType:
  RPC_WIDE = 0
  RPC_FOVEA = 1

  _VALUES_TO_NAMES = {
    0: "RPC_WIDE",
    1: "RPC_FOVEA",
  }

  _NAMES_TO_VALUES = {
    "RPC_WIDE": 0,
    "RPC_FOVEA": 1,
  }

class RpcMotorMode:
  RPC_TIME = 1
  RPC_SPEED = 2

  _VALUES_TO_NAMES = {
    1: "RPC_TIME",
    2: "RPC_SPEED",
  }

  _NAMES_TO_VALUES = {
    "RPC_TIME": 1,
    "RPC_SPEED": 2,
  }

class RpcWorkMode:
  RPC_CORE_PASSIVE_WORKMODE = 16842752
  RPC_CORE_CATCHALL_WORKMODE = 16908288
  RPC_CORE_FOLLOW_WORKMODE = 17039360

  _VALUES_TO_NAMES = {
    16842752: "RPC_CORE_PASSIVE_WORKMODE",
    16908288: "RPC_CORE_CATCHALL_WORKMODE",
    17039360: "RPC_CORE_FOLLOW_WORKMODE",
  }

  _NAMES_TO_VALUES = {
    "RPC_CORE_PASSIVE_WORKMODE": 16842752,
    "RPC_CORE_CATCHALL_WORKMODE": 16908288,
    "RPC_CORE_FOLLOW_WORKMODE": 17039360,
  }

class RpcRotateType:
  RpcMoveLeft = 0
  RpcMoveRight = 1
  RpcMoveUp = 2
  RpcMoveDown = 3
  RpcMoveUpLeft = 4
  RpcMoveUpRight = 5
  RpcMoveDownLeft = 6
  RpcMoveDownRight = 7

  _VALUES_TO_NAMES = {
    0: "RpcMoveLeft",
    1: "RpcMoveRight",
    2: "RpcMoveUp",
    3: "RpcMoveDown",
    4: "RpcMoveUpLeft",
    5: "RpcMoveUpRight",
    6: "RpcMoveDownLeft",
    7: "RpcMoveDownRight",
  }

  _NAMES_TO_VALUES = {
    "RpcMoveLeft": 0,
    "RpcMoveRight": 1,
    "RpcMoveUp": 2,
    "RpcMoveDown": 3,
    "RpcMoveUpLeft": 4,
    "RpcMoveUpRight": 5,
    "RpcMoveDownLeft": 6,
    "RpcMoveDownRight": 7,
  }

class RpcRotateStep:
  Rpc1Level = 0
  Rpc2Level = 1
  Rpc3Level = 2
  Rpc4Level = 3
  Rpc5Level = 4
  Rpc6Level = 5

  _VALUES_TO_NAMES = {
    0: "Rpc1Level",
    1: "Rpc2Level",
    2: "Rpc3Level",
    3: "Rpc4Level",
    4: "Rpc5Level",
    5: "Rpc6Level",
  }

  _NAMES_TO_VALUES = {
    "Rpc1Level": 0,
    "Rpc2Level": 1,
    "Rpc3Level": 2,
    "Rpc4Level": 3,
    "Rpc5Level": 4,
    "Rpc6Level": 5,
  }

class RpcSnapType:
  RpcFace = 0
  RpcBody = 1
  RpcCar = 2

  _VALUES_TO_NAMES = {
    0: "RpcFace",
    1: "RpcBody",
    2: "RpcCar",
  }

  _NAMES_TO_VALUES = {
    "RpcFace": 0,
    "RpcBody": 1,
    "RpcCar": 2,
  }

class RpcStreamType:
  RpcMainStream = 0
  RpcSubStream = 1

  _VALUES_TO_NAMES = {
    0: "RpcMainStream",
    1: "RpcSubStream",
  }

  _NAMES_TO_VALUES = {
    "RpcMainStream": 0,
    "RpcSubStream": 1,
  }

class RpcTextType:
  RpcTimeText = 0
  RpcDescText = 1
  RpcSnapText = 2

  _VALUES_TO_NAMES = {
    0: "RpcTimeText",
    1: "RpcDescText",
    2: "RpcSnapText",
  }

  _NAMES_TO_VALUES = {
    "RpcTimeText": 0,
    "RpcDescText": 1,
    "RpcSnapText": 2,
  }

class RpcStreamResolution:
  RPC_FHD = 0
  RPC_UXGA = 1
  RPC_XGA = 2
  RPC_VGA = 3
  RPC_HD = 4

  _VALUES_TO_NAMES = {
    0: "RPC_FHD",
    1: "RPC_UXGA",
    2: "RPC_XGA",
    3: "RPC_VGA",
    4: "RPC_HD",
  }

  _NAMES_TO_VALUES = {
    "RPC_FHD": 0,
    "RPC_UXGA": 1,
    "RPC_XGA": 2,
    "RPC_VGA": 3,
    "RPC_HD": 4,
  }

class RpcTargetSize:
  RPC_TAR_SMALL = 0
  RPC_TAR_MIDDLE = 1
  RPC_TAR_LARGE = 2

  _VALUES_TO_NAMES = {
    0: "RPC_TAR_SMALL",
    1: "RPC_TAR_MIDDLE",
    2: "RPC_TAR_LARGE",
  }

  _NAMES_TO_VALUES = {
    "RPC_TAR_SMALL": 0,
    "RPC_TAR_MIDDLE": 1,
    "RPC_TAR_LARGE": 2,
  }

class RpcTextAlignType:
  RPC_UPPERLEFT_ALIGN = 0
  RPC_LOWERLEFT_ALIGN = 1
  RPC_UPPERRIGHT_ALIGN = 2
  RPC_LOWERRIGHT_ALIGN = 3

  _VALUES_TO_NAMES = {
    0: "RPC_UPPERLEFT_ALIGN",
    1: "RPC_LOWERLEFT_ALIGN",
    2: "RPC_UPPERRIGHT_ALIGN",
    3: "RPC_LOWERRIGHT_ALIGN",
  }

  _NAMES_TO_VALUES = {
    "RPC_UPPERLEFT_ALIGN": 0,
    "RPC_LOWERLEFT_ALIGN": 1,
    "RPC_UPPERRIGHT_ALIGN": 2,
    "RPC_LOWERRIGHT_ALIGN": 3,
  }

class RpcImgFormat:
  RPC_JPEG = 0

  _VALUES_TO_NAMES = {
    0: "RPC_JPEG",
  }

  _NAMES_TO_VALUES = {
    "RPC_JPEG": 0,
  }

class RpcSmartStreamType:
  RPC_SINGLESTREAM_SNAPONTOP = 0
  RPC_SINGLESTREAM_SNAPONBOTTOM = 1
  RPC_SINGLESTREAM_NOSNAP = 2

  _VALUES_TO_NAMES = {
    0: "RPC_SINGLESTREAM_SNAPONTOP",
    1: "RPC_SINGLESTREAM_SNAPONBOTTOM",
    2: "RPC_SINGLESTREAM_NOSNAP",
  }

  _NAMES_TO_VALUES = {
    "RPC_SINGLESTREAM_SNAPONTOP": 0,
    "RPC_SINGLESTREAM_SNAPONBOTTOM": 1,
    "RPC_SINGLESTREAM_NOSNAP": 2,
  }

class RpcUndistortImgType:
  RPC_UNDISTORT_1080P = 0
  RPC_UNDISTORT_720P = 1
  RPC_UNDISTORT_540P = 2
  RPC_UNDISTORT_CROP = 3

  _VALUES_TO_NAMES = {
    0: "RPC_UNDISTORT_1080P",
    1: "RPC_UNDISTORT_720P",
    2: "RPC_UNDISTORT_540P",
    3: "RPC_UNDISTORT_CROP",
  }

  _NAMES_TO_VALUES = {
    "RPC_UNDISTORT_1080P": 0,
    "RPC_UNDISTORT_720P": 1,
    "RPC_UNDISTORT_540P": 2,
    "RPC_UNDISTORT_CROP": 3,
  }


class RpcLibraFException(TException):
  """
  Attributes:
   - err_type
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'err_type', None, None, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
  )

  def __init__(self, err_type=None, msg=None,):
    self.err_type = err_type
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.err_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcLibraFException')
    if self.err_type is not None:
      oprot.writeFieldBegin('err_type', TType.I32, 1)
      oprot.writeI32(self.err_type)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.err_type)
    value = (value * 31) ^ hash(self.msg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcPoint:
  """
  a point's coordinates (x, y) are ratios w.r.t. the image width and height *

  Attributes:
   - x
   - y
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'x', None, 0.5, ), # 1
    (2, TType.DOUBLE, 'y', None, 0.5, ), # 2
  )

  def __init__(self, x=thrift_spec[1][4], y=thrift_spec[2][4],):
    self.x = x
    self.y = y

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.x = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.y = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcPoint')
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.DOUBLE, 1)
      oprot.writeDouble(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.DOUBLE, 2)
      oprot.writeDouble(self.y)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.x)
    value = (value * 31) ^ hash(self.y)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcResolution:
  """
  Attributes:
   - width
   - height
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'width', None, 0, ), # 1
    (2, TType.I32, 'height', None, 0, ), # 2
  )

  def __init__(self, width=thrift_spec[1][4], height=thrift_spec[2][4],):
    self.width = width
    self.height = height

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.width = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.height = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcResolution')
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I32, 1)
      oprot.writeI32(self.width)
      oprot.writeFieldEnd()
    if self.height is not None:
      oprot.writeFieldBegin('height', TType.I32, 2)
      oprot.writeI32(self.height)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.width)
    value = (value * 31) ^ hash(self.height)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcRect:
  """
  Attributes:
   - x
   - y
   - width
   - height
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'x', None, 0, ), # 1
    (2, TType.DOUBLE, 'y', None, 0, ), # 2
    (3, TType.DOUBLE, 'width', None, 0, ), # 3
    (4, TType.DOUBLE, 'height', None, 0, ), # 4
  )

  def __init__(self, x=thrift_spec[1][4], y=thrift_spec[2][4], width=thrift_spec[3][4], height=thrift_spec[4][4],):
    self.x = x
    self.y = y
    self.width = width
    self.height = height

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.x = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.y = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.width = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.height = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcRect')
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.DOUBLE, 1)
      oprot.writeDouble(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.DOUBLE, 2)
      oprot.writeDouble(self.y)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.DOUBLE, 3)
      oprot.writeDouble(self.width)
      oprot.writeFieldEnd()
    if self.height is not None:
      oprot.writeFieldBegin('height', TType.DOUBLE, 4)
      oprot.writeDouble(self.height)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.x)
    value = (value * 31) ^ hash(self.y)
    value = (value * 31) ^ hash(self.width)
    value = (value * 31) ^ hash(self.height)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcGrid:
  """
  Attributes:
   - roi
   - rows
   - cols
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'roi', (RpcRect, RpcRect.thrift_spec), None, ), # 1
    (2, TType.I32, 'rows', None, 1, ), # 2
    (3, TType.I32, 'cols', None, 1, ), # 3
  )

  def __init__(self, roi=None, rows=thrift_spec[2][4], cols=thrift_spec[3][4],):
    self.roi = roi
    self.rows = rows
    self.cols = cols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.roi = RpcRect()
          self.roi.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.rows = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cols = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcGrid')
    if self.roi is not None:
      oprot.writeFieldBegin('roi', TType.STRUCT, 1)
      self.roi.write(oprot)
      oprot.writeFieldEnd()
    if self.rows is not None:
      oprot.writeFieldBegin('rows', TType.I32, 2)
      oprot.writeI32(self.rows)
      oprot.writeFieldEnd()
    if self.cols is not None:
      oprot.writeFieldBegin('cols', TType.I32, 3)
      oprot.writeI32(self.cols)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roi)
    value = (value * 31) ^ hash(self.rows)
    value = (value * 31) ^ hash(self.cols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcSensorProp:
  """
  Attributes:
   - resolution
   - exposure
   - exposure_auto
   - shutter
   - shutter_auto
   - fps
   - fps_auto
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'resolution', (RpcResolution, RpcResolution.thrift_spec), None, ), # 1
    (2, TType.DOUBLE, 'exposure', None, 1, ), # 2
    (3, TType.BOOL, 'exposure_auto', None, True, ), # 3
    (4, TType.DOUBLE, 'shutter', None, 0.01, ), # 4
    (5, TType.BOOL, 'shutter_auto', None, False, ), # 5
    (6, TType.DOUBLE, 'fps', None, 20, ), # 6
    (7, TType.BOOL, 'fps_auto', None, False, ), # 7
  )

  def __init__(self, resolution=None, exposure=thrift_spec[2][4], exposure_auto=thrift_spec[3][4], shutter=thrift_spec[4][4], shutter_auto=thrift_spec[5][4], fps=thrift_spec[6][4], fps_auto=thrift_spec[7][4],):
    self.resolution = resolution
    self.exposure = exposure
    self.exposure_auto = exposure_auto
    self.shutter = shutter
    self.shutter_auto = shutter_auto
    self.fps = fps
    self.fps_auto = fps_auto

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.resolution = RpcResolution()
          self.resolution.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.exposure = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.exposure_auto = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.shutter = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.shutter_auto = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.fps = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.fps_auto = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcSensorProp')
    if self.resolution is not None:
      oprot.writeFieldBegin('resolution', TType.STRUCT, 1)
      self.resolution.write(oprot)
      oprot.writeFieldEnd()
    if self.exposure is not None:
      oprot.writeFieldBegin('exposure', TType.DOUBLE, 2)
      oprot.writeDouble(self.exposure)
      oprot.writeFieldEnd()
    if self.exposure_auto is not None:
      oprot.writeFieldBegin('exposure_auto', TType.BOOL, 3)
      oprot.writeBool(self.exposure_auto)
      oprot.writeFieldEnd()
    if self.shutter is not None:
      oprot.writeFieldBegin('shutter', TType.DOUBLE, 4)
      oprot.writeDouble(self.shutter)
      oprot.writeFieldEnd()
    if self.shutter_auto is not None:
      oprot.writeFieldBegin('shutter_auto', TType.BOOL, 5)
      oprot.writeBool(self.shutter_auto)
      oprot.writeFieldEnd()
    if self.fps is not None:
      oprot.writeFieldBegin('fps', TType.DOUBLE, 6)
      oprot.writeDouble(self.fps)
      oprot.writeFieldEnd()
    if self.fps_auto is not None:
      oprot.writeFieldBegin('fps_auto', TType.BOOL, 7)
      oprot.writeBool(self.fps_auto)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resolution)
    value = (value * 31) ^ hash(self.exposure)
    value = (value * 31) ^ hash(self.exposure_auto)
    value = (value * 31) ^ hash(self.shutter)
    value = (value * 31) ^ hash(self.shutter_auto)
    value = (value * 31) ^ hash(self.fps)
    value = (value * 31) ^ hash(self.fps_auto)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcMotorProp:
  """
  Attributes:
   - mode
   - mode_val
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'mode', None,     1, ), # 1
    (2, TType.DOUBLE, 'mode_val', None, 0.05, ), # 2
  )

  def __init__(self, mode=thrift_spec[1][4], mode_val=thrift_spec[2][4],):
    self.mode = mode
    self.mode_val = mode_val

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.mode_val = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcMotorProp')
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 1)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    if self.mode_val is not None:
      oprot.writeFieldBegin('mode_val', TType.DOUBLE, 2)
      oprot.writeDouble(self.mode_val)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mode)
    value = (value * 31) ^ hash(self.mode_val)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcDetectProp:
  """
  Attributes:
   - polygons
   - dist
   - threshold
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'polygons', (TType.LIST,(TType.STRUCT,(RpcPoint, RpcPoint.thrift_spec))), None, ), # 1
    (2, TType.I32, 'dist', None, 50, ), # 2
    (3, TType.DOUBLE, 'threshold', None, 0.95, ), # 3
  )

  def __init__(self, polygons=None, dist=thrift_spec[2][4], threshold=thrift_spec[3][4],):
    self.polygons = polygons
    self.dist = dist
    self.threshold = threshold

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.polygons = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = []
            (_etype9, _size6) = iprot.readListBegin()
            for _i10 in xrange(_size6):
              _elem11 = RpcPoint()
              _elem11.read(iprot)
              _elem5.append(_elem11)
            iprot.readListEnd()
            self.polygons.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dist = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.threshold = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcDetectProp')
    if self.polygons is not None:
      oprot.writeFieldBegin('polygons', TType.LIST, 1)
      oprot.writeListBegin(TType.LIST, len(self.polygons))
      for iter12 in self.polygons:
        oprot.writeListBegin(TType.STRUCT, len(iter12))
        for iter13 in iter12:
          iter13.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dist is not None:
      oprot.writeFieldBegin('dist', TType.I32, 2)
      oprot.writeI32(self.dist)
      oprot.writeFieldEnd()
    if self.threshold is not None:
      oprot.writeFieldBegin('threshold', TType.DOUBLE, 3)
      oprot.writeDouble(self.threshold)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.polygons)
    value = (value * 31) ^ hash(self.dist)
    value = (value * 31) ^ hash(self.threshold)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcLayoutProp:
  """
  Attributes:
   - default_layout
   - pip_on
   - pip_fixed
   - pip_roi
   - snap_cols
   - snap_rows
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'default_layout', None, True, ), # 1
    (2, TType.BOOL, 'pip_on', None, True, ), # 2
    (3, TType.BOOL, 'pip_fixed', None, True, ), # 3
    (4, TType.STRUCT, 'pip_roi', (RpcRect, RpcRect.thrift_spec), None, ), # 4
    (5, TType.I32, 'snap_cols', None, 6, ), # 5
    (6, TType.I32, 'snap_rows', None, 1, ), # 6
  )

  def __init__(self, default_layout=thrift_spec[1][4], pip_on=thrift_spec[2][4], pip_fixed=thrift_spec[3][4], pip_roi=None, snap_cols=thrift_spec[5][4], snap_rows=thrift_spec[6][4],):
    self.default_layout = default_layout
    self.pip_on = pip_on
    self.pip_fixed = pip_fixed
    self.pip_roi = pip_roi
    self.snap_cols = snap_cols
    self.snap_rows = snap_rows

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.default_layout = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.pip_on = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.pip_fixed = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.pip_roi = RpcRect()
          self.pip_roi.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.snap_cols = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.snap_rows = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcLayoutProp')
    if self.default_layout is not None:
      oprot.writeFieldBegin('default_layout', TType.BOOL, 1)
      oprot.writeBool(self.default_layout)
      oprot.writeFieldEnd()
    if self.pip_on is not None:
      oprot.writeFieldBegin('pip_on', TType.BOOL, 2)
      oprot.writeBool(self.pip_on)
      oprot.writeFieldEnd()
    if self.pip_fixed is not None:
      oprot.writeFieldBegin('pip_fixed', TType.BOOL, 3)
      oprot.writeBool(self.pip_fixed)
      oprot.writeFieldEnd()
    if self.pip_roi is not None:
      oprot.writeFieldBegin('pip_roi', TType.STRUCT, 4)
      self.pip_roi.write(oprot)
      oprot.writeFieldEnd()
    if self.snap_cols is not None:
      oprot.writeFieldBegin('snap_cols', TType.I32, 5)
      oprot.writeI32(self.snap_cols)
      oprot.writeFieldEnd()
    if self.snap_rows is not None:
      oprot.writeFieldBegin('snap_rows', TType.I32, 6)
      oprot.writeI32(self.snap_rows)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.default_layout)
    value = (value * 31) ^ hash(self.pip_on)
    value = (value * 31) ^ hash(self.pip_fixed)
    value = (value * 31) ^ hash(self.pip_roi)
    value = (value * 31) ^ hash(self.snap_cols)
    value = (value * 31) ^ hash(self.snap_rows)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcMat:
  """
  Attributes:
   - data
   - rows
   - cols
   - type_size
   - dims
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'data', None, None, ), # 1
    (2, TType.I32, 'rows', None, None, ), # 2
    (3, TType.I32, 'cols', None, None, ), # 3
    (4, TType.I16, 'type_size', None, None, ), # 4
    (5, TType.I16, 'dims', None, None, ), # 5
  )

  def __init__(self, data=None, rows=None, cols=None, type_size=None, dims=None,):
    self.data = data
    self.rows = rows
    self.cols = cols
    self.type_size = type_size
    self.dims = dims

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.rows = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cols = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.type_size = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.dims = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcMat')
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 1)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    if self.rows is not None:
      oprot.writeFieldBegin('rows', TType.I32, 2)
      oprot.writeI32(self.rows)
      oprot.writeFieldEnd()
    if self.cols is not None:
      oprot.writeFieldBegin('cols', TType.I32, 3)
      oprot.writeI32(self.cols)
      oprot.writeFieldEnd()
    if self.type_size is not None:
      oprot.writeFieldBegin('type_size', TType.I16, 4)
      oprot.writeI16(self.type_size)
      oprot.writeFieldEnd()
    if self.dims is not None:
      oprot.writeFieldBegin('dims', TType.I16, 5)
      oprot.writeI16(self.dims)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.data)
    value = (value * 31) ^ hash(self.rows)
    value = (value * 31) ^ hash(self.cols)
    value = (value * 31) ^ hash(self.type_size)
    value = (value * 31) ^ hash(self.dims)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcColor:
  """
  Attributes:
   - val0
   - val1
   - val2
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'val0', None, 0, ), # 1
    (2, TType.I16, 'val1', None, 0, ), # 2
    (3, TType.I16, 'val2', None, 0, ), # 3
  )

  def __init__(self, val0=thrift_spec[1][4], val1=thrift_spec[2][4], val2=thrift_spec[3][4],):
    self.val0 = val0
    self.val1 = val1
    self.val2 = val2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.val0 = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.val1 = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.val2 = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcColor')
    if self.val0 is not None:
      oprot.writeFieldBegin('val0', TType.I16, 1)
      oprot.writeI16(self.val0)
      oprot.writeFieldEnd()
    if self.val1 is not None:
      oprot.writeFieldBegin('val1', TType.I16, 2)
      oprot.writeI16(self.val1)
      oprot.writeFieldEnd()
    if self.val2 is not None:
      oprot.writeFieldBegin('val2', TType.I16, 3)
      oprot.writeI16(self.val2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.val0)
    value = (value * 31) ^ hash(self.val1)
    value = (value * 31) ^ hash(self.val2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcDayNightTime:
  """
  Attributes:
   - is_auto
   - is_bw
   - start_tm
   - end_tm
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_auto', None, False, ), # 1
    (2, TType.BOOL, 'is_bw', None, True, ), # 2
    (3, TType.I32, 'start_tm', None, 1900, ), # 3
    (4, TType.I32, 'end_tm', None, 700, ), # 4
  )

  def __init__(self, is_auto=thrift_spec[1][4], is_bw=thrift_spec[2][4], start_tm=thrift_spec[3][4], end_tm=thrift_spec[4][4],):
    self.is_auto = is_auto
    self.is_bw = is_bw
    self.start_tm = start_tm
    self.end_tm = end_tm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_auto = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_bw = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.start_tm = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.end_tm = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcDayNightTime')
    if self.is_auto is not None:
      oprot.writeFieldBegin('is_auto', TType.BOOL, 1)
      oprot.writeBool(self.is_auto)
      oprot.writeFieldEnd()
    if self.is_bw is not None:
      oprot.writeFieldBegin('is_bw', TType.BOOL, 2)
      oprot.writeBool(self.is_bw)
      oprot.writeFieldEnd()
    if self.start_tm is not None:
      oprot.writeFieldBegin('start_tm', TType.I32, 3)
      oprot.writeI32(self.start_tm)
      oprot.writeFieldEnd()
    if self.end_tm is not None:
      oprot.writeFieldBegin('end_tm', TType.I32, 4)
      oprot.writeI32(self.end_tm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_auto)
    value = (value * 31) ^ hash(self.is_bw)
    value = (value * 31) ^ hash(self.start_tm)
    value = (value * 31) ^ hash(self.end_tm)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcFontProperties:
  """
  Attributes:
   - font_filename
   - font_size
   - interval_scale
   - space_scale
   - pos_ll
   - text_align
   - font_color
   - outline_color
   - is_display
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'font_filename', None, "../data/truetype/simsun.ttf", ), # 1
    (2, TType.I16, 'font_size', None, 20, ), # 2
    (3, TType.DOUBLE, 'interval_scale', None, 0.1, ), # 3
    (4, TType.DOUBLE, 'space_scale', None, 0.5, ), # 4
    (5, TType.STRUCT, 'pos_ll', (RpcPoint, RpcPoint.thrift_spec), None, ), # 5
    (6, TType.I32, 'text_align', None, None, ), # 6
    (7, TType.STRUCT, 'font_color', (RpcColor, RpcColor.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'outline_color', (RpcColor, RpcColor.thrift_spec), None, ), # 8
    (9, TType.BOOL, 'is_display', None, True, ), # 9
  )

  def __init__(self, font_filename=thrift_spec[1][4], font_size=thrift_spec[2][4], interval_scale=thrift_spec[3][4], space_scale=thrift_spec[4][4], pos_ll=None, text_align=None, font_color=None, outline_color=None, is_display=thrift_spec[9][4],):
    self.font_filename = font_filename
    self.font_size = font_size
    self.interval_scale = interval_scale
    self.space_scale = space_scale
    self.pos_ll = pos_ll
    self.text_align = text_align
    self.font_color = font_color
    self.outline_color = outline_color
    self.is_display = is_display

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.font_filename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.font_size = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.interval_scale = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.space_scale = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.pos_ll = RpcPoint()
          self.pos_ll.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.text_align = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.font_color = RpcColor()
          self.font_color.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.outline_color = RpcColor()
          self.outline_color.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.is_display = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcFontProperties')
    if self.font_filename is not None:
      oprot.writeFieldBegin('font_filename', TType.STRING, 1)
      oprot.writeString(self.font_filename)
      oprot.writeFieldEnd()
    if self.font_size is not None:
      oprot.writeFieldBegin('font_size', TType.I16, 2)
      oprot.writeI16(self.font_size)
      oprot.writeFieldEnd()
    if self.interval_scale is not None:
      oprot.writeFieldBegin('interval_scale', TType.DOUBLE, 3)
      oprot.writeDouble(self.interval_scale)
      oprot.writeFieldEnd()
    if self.space_scale is not None:
      oprot.writeFieldBegin('space_scale', TType.DOUBLE, 4)
      oprot.writeDouble(self.space_scale)
      oprot.writeFieldEnd()
    if self.pos_ll is not None:
      oprot.writeFieldBegin('pos_ll', TType.STRUCT, 5)
      self.pos_ll.write(oprot)
      oprot.writeFieldEnd()
    if self.text_align is not None:
      oprot.writeFieldBegin('text_align', TType.I32, 6)
      oprot.writeI32(self.text_align)
      oprot.writeFieldEnd()
    if self.font_color is not None:
      oprot.writeFieldBegin('font_color', TType.STRUCT, 7)
      self.font_color.write(oprot)
      oprot.writeFieldEnd()
    if self.outline_color is not None:
      oprot.writeFieldBegin('outline_color', TType.STRUCT, 8)
      self.outline_color.write(oprot)
      oprot.writeFieldEnd()
    if self.is_display is not None:
      oprot.writeFieldBegin('is_display', TType.BOOL, 9)
      oprot.writeBool(self.is_display)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.font_filename)
    value = (value * 31) ^ hash(self.font_size)
    value = (value * 31) ^ hash(self.interval_scale)
    value = (value * 31) ^ hash(self.space_scale)
    value = (value * 31) ^ hash(self.pos_ll)
    value = (value * 31) ^ hash(self.text_align)
    value = (value * 31) ^ hash(self.font_color)
    value = (value * 31) ^ hash(self.outline_color)
    value = (value * 31) ^ hash(self.is_display)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcOSDOther:
  """
  Attributes:
   - is_24hour
   - show_weekday
   - zh_str
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_24hour', None, True, ), # 1
    (2, TType.BOOL, 'show_weekday', None, True, ), # 2
    (3, TType.STRING, 'zh_str', None, "", ), # 3
  )

  def __init__(self, is_24hour=thrift_spec[1][4], show_weekday=thrift_spec[2][4], zh_str=thrift_spec[3][4],):
    self.is_24hour = is_24hour
    self.show_weekday = show_weekday
    self.zh_str = zh_str

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_24hour = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.show_weekday = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.zh_str = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcOSDOther')
    if self.is_24hour is not None:
      oprot.writeFieldBegin('is_24hour', TType.BOOL, 1)
      oprot.writeBool(self.is_24hour)
      oprot.writeFieldEnd()
    if self.show_weekday is not None:
      oprot.writeFieldBegin('show_weekday', TType.BOOL, 2)
      oprot.writeBool(self.show_weekday)
      oprot.writeFieldEnd()
    if self.zh_str is not None:
      oprot.writeFieldBegin('zh_str', TType.STRING, 3)
      oprot.writeString(self.zh_str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_24hour)
    value = (value * 31) ^ hash(self.show_weekday)
    value = (value * 31) ^ hash(self.zh_str)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcStreamProperties:
  """
  Attributes:
   - res
   - is_bitrate_variable
   - bitrate
   - fps
   - kframe_interval
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'res', None, None, ), # 1
    (2, TType.BOOL, 'is_bitrate_variable', None, False, ), # 2
    (3, TType.I32, 'bitrate', None, 4000, ), # 3
    (4, TType.I16, 'fps', None, 20, ), # 4
    (5, TType.I16, 'kframe_interval', None, 15, ), # 5
  )

  def __init__(self, res=None, is_bitrate_variable=thrift_spec[2][4], bitrate=thrift_spec[3][4], fps=thrift_spec[4][4], kframe_interval=thrift_spec[5][4],):
    self.res = res
    self.is_bitrate_variable = is_bitrate_variable
    self.bitrate = bitrate
    self.fps = fps
    self.kframe_interval = kframe_interval

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.res = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_bitrate_variable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.bitrate = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.fps = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.kframe_interval = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcStreamProperties')
    if self.res is not None:
      oprot.writeFieldBegin('res', TType.I32, 1)
      oprot.writeI32(self.res)
      oprot.writeFieldEnd()
    if self.is_bitrate_variable is not None:
      oprot.writeFieldBegin('is_bitrate_variable', TType.BOOL, 2)
      oprot.writeBool(self.is_bitrate_variable)
      oprot.writeFieldEnd()
    if self.bitrate is not None:
      oprot.writeFieldBegin('bitrate', TType.I32, 3)
      oprot.writeI32(self.bitrate)
      oprot.writeFieldEnd()
    if self.fps is not None:
      oprot.writeFieldBegin('fps', TType.I16, 4)
      oprot.writeI16(self.fps)
      oprot.writeFieldEnd()
    if self.kframe_interval is not None:
      oprot.writeFieldBegin('kframe_interval', TType.I16, 5)
      oprot.writeI16(self.kframe_interval)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.res)
    value = (value * 31) ^ hash(self.is_bitrate_variable)
    value = (value * 31) ^ hash(self.bitrate)
    value = (value * 31) ^ hash(self.fps)
    value = (value * 31) ^ hash(self.kframe_interval)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcTwoStreamProperties:
  """
  Attributes:
   - main_res
   - main_bitrate_variable
   - main_bitrate
   - main_fps
   - main_kframe_interval
   - sub_bitrate_variable
   - sub_bitrate
   - sub_fps
   - sub_kframe_interval
   - is_sub_on
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'main_res', None, None, ), # 1
    (2, TType.BOOL, 'main_bitrate_variable', None, False, ), # 2
    (3, TType.I32, 'main_bitrate', None, 5000, ), # 3
    (4, TType.I32, 'main_fps', None, 20, ), # 4
    (5, TType.I32, 'main_kframe_interval', None, 100, ), # 5
    (6, TType.BOOL, 'sub_bitrate_variable', None, False, ), # 6
    (7, TType.I32, 'sub_bitrate', None, 1000, ), # 7
    (8, TType.I32, 'sub_fps', None, 20, ), # 8
    (9, TType.I32, 'sub_kframe_interval', None, 100, ), # 9
    (10, TType.BOOL, 'is_sub_on', None, True, ), # 10
  )

  def __init__(self, main_res=None, main_bitrate_variable=thrift_spec[2][4], main_bitrate=thrift_spec[3][4], main_fps=thrift_spec[4][4], main_kframe_interval=thrift_spec[5][4], sub_bitrate_variable=thrift_spec[6][4], sub_bitrate=thrift_spec[7][4], sub_fps=thrift_spec[8][4], sub_kframe_interval=thrift_spec[9][4], is_sub_on=thrift_spec[10][4],):
    self.main_res = main_res
    self.main_bitrate_variable = main_bitrate_variable
    self.main_bitrate = main_bitrate
    self.main_fps = main_fps
    self.main_kframe_interval = main_kframe_interval
    self.sub_bitrate_variable = sub_bitrate_variable
    self.sub_bitrate = sub_bitrate
    self.sub_fps = sub_fps
    self.sub_kframe_interval = sub_kframe_interval
    self.is_sub_on = is_sub_on

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.main_res = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.main_bitrate_variable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.main_bitrate = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.main_fps = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.main_kframe_interval = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.sub_bitrate_variable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.sub_bitrate = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.sub_fps = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.sub_kframe_interval = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.is_sub_on = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcTwoStreamProperties')
    if self.main_res is not None:
      oprot.writeFieldBegin('main_res', TType.I32, 1)
      oprot.writeI32(self.main_res)
      oprot.writeFieldEnd()
    if self.main_bitrate_variable is not None:
      oprot.writeFieldBegin('main_bitrate_variable', TType.BOOL, 2)
      oprot.writeBool(self.main_bitrate_variable)
      oprot.writeFieldEnd()
    if self.main_bitrate is not None:
      oprot.writeFieldBegin('main_bitrate', TType.I32, 3)
      oprot.writeI32(self.main_bitrate)
      oprot.writeFieldEnd()
    if self.main_fps is not None:
      oprot.writeFieldBegin('main_fps', TType.I32, 4)
      oprot.writeI32(self.main_fps)
      oprot.writeFieldEnd()
    if self.main_kframe_interval is not None:
      oprot.writeFieldBegin('main_kframe_interval', TType.I32, 5)
      oprot.writeI32(self.main_kframe_interval)
      oprot.writeFieldEnd()
    if self.sub_bitrate_variable is not None:
      oprot.writeFieldBegin('sub_bitrate_variable', TType.BOOL, 6)
      oprot.writeBool(self.sub_bitrate_variable)
      oprot.writeFieldEnd()
    if self.sub_bitrate is not None:
      oprot.writeFieldBegin('sub_bitrate', TType.I32, 7)
      oprot.writeI32(self.sub_bitrate)
      oprot.writeFieldEnd()
    if self.sub_fps is not None:
      oprot.writeFieldBegin('sub_fps', TType.I32, 8)
      oprot.writeI32(self.sub_fps)
      oprot.writeFieldEnd()
    if self.sub_kframe_interval is not None:
      oprot.writeFieldBegin('sub_kframe_interval', TType.I32, 9)
      oprot.writeI32(self.sub_kframe_interval)
      oprot.writeFieldEnd()
    if self.is_sub_on is not None:
      oprot.writeFieldBegin('is_sub_on', TType.BOOL, 10)
      oprot.writeBool(self.is_sub_on)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.main_res)
    value = (value * 31) ^ hash(self.main_bitrate_variable)
    value = (value * 31) ^ hash(self.main_bitrate)
    value = (value * 31) ^ hash(self.main_fps)
    value = (value * 31) ^ hash(self.main_kframe_interval)
    value = (value * 31) ^ hash(self.sub_bitrate_variable)
    value = (value * 31) ^ hash(self.sub_bitrate)
    value = (value * 31) ^ hash(self.sub_fps)
    value = (value * 31) ^ hash(self.sub_kframe_interval)
    value = (value * 31) ^ hash(self.is_sub_on)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcImgTransProperties:
  """
  Attributes:
   - format
   - ip
   - port
   - is_snap_trans
   - is_fovea_trans
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'format', None, None, ), # 1
    (2, TType.STRING, 'ip', None, "127.0.0.1", ), # 2
    (3, TType.I16, 'port', None, 9900, ), # 3
    (4, TType.BOOL, 'is_snap_trans', None, True, ), # 4
    (5, TType.BOOL, 'is_fovea_trans', None, False, ), # 5
  )

  def __init__(self, format=None, ip=thrift_spec[2][4], port=thrift_spec[3][4], is_snap_trans=thrift_spec[4][4], is_fovea_trans=thrift_spec[5][4],):
    self.format = format
    self.ip = ip
    self.port = port
    self.is_snap_trans = is_snap_trans
    self.is_fovea_trans = is_fovea_trans

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.format = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ip = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.port = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_snap_trans = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_fovea_trans = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcImgTransProperties')
    if self.format is not None:
      oprot.writeFieldBegin('format', TType.I32, 1)
      oprot.writeI32(self.format)
      oprot.writeFieldEnd()
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRING, 2)
      oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I16, 3)
      oprot.writeI16(self.port)
      oprot.writeFieldEnd()
    if self.is_snap_trans is not None:
      oprot.writeFieldBegin('is_snap_trans', TType.BOOL, 4)
      oprot.writeBool(self.is_snap_trans)
      oprot.writeFieldEnd()
    if self.is_fovea_trans is not None:
      oprot.writeFieldBegin('is_fovea_trans', TType.BOOL, 5)
      oprot.writeBool(self.is_fovea_trans)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.format)
    value = (value * 31) ^ hash(self.ip)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.is_snap_trans)
    value = (value * 31) ^ hash(self.is_fovea_trans)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcSnapProps:
  """
  Attributes:
   - snap_props
   - server_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'snap_props', (TType.I32,None,TType.STRUCT,(RpcImgTransProperties, RpcImgTransProperties.thrift_spec)), None, ), # 1
    (2, TType.I16, 'server_port', None, None, ), # 2
  )

  def __init__(self, snap_props=None, server_port=None,):
    self.snap_props = snap_props
    self.server_port = server_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.snap_props = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin()
          for _i18 in xrange(_size14):
            _key19 = iprot.readI32()
            _val20 = RpcImgTransProperties()
            _val20.read(iprot)
            self.snap_props[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.server_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcSnapProps')
    if self.snap_props is not None:
      oprot.writeFieldBegin('snap_props', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.snap_props))
      for kiter21,viter22 in self.snap_props.items():
        oprot.writeI32(kiter21)
        viter22.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.server_port is not None:
      oprot.writeFieldBegin('server_port', TType.I16, 2)
      oprot.writeI16(self.server_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snap_props)
    value = (value * 31) ^ hash(self.server_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RpcSnapConnectInfo:
  """
  Attributes:
   - num_cur_connect
   - num_max_connect
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'num_cur_connect', None, 0, ), # 1
    (2, TType.I16, 'num_max_connect', None, 2, ), # 2
  )

  def __init__(self, num_cur_connect=thrift_spec[1][4], num_max_connect=thrift_spec[2][4],):
    self.num_cur_connect = num_cur_connect
    self.num_max_connect = num_max_connect

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.num_cur_connect = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.num_max_connect = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RpcSnapConnectInfo')
    if self.num_cur_connect is not None:
      oprot.writeFieldBegin('num_cur_connect', TType.I16, 1)
      oprot.writeI16(self.num_cur_connect)
      oprot.writeFieldEnd()
    if self.num_max_connect is not None:
      oprot.writeFieldBegin('num_max_connect', TType.I16, 2)
      oprot.writeI16(self.num_max_connect)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.num_cur_connect)
    value = (value * 31) ^ hash(self.num_max_connect)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
