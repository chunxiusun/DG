#-*- coding:utf-8 -*-
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def Stop(self):
    pass

  def GetWorkMode(self):
    """
    获取工作模式　get work mode *
    """
    pass

  def SetWorkMode(self, work_mode):
    """
    设置工作模式　set work mode, return false if failed to switch work mode *

    Parameters:
     - work_mode
    """
    pass

  def SwitchToPassiveModeWithTimer(self):
    """
    切换到手动模式，一段时间不进行操作则自动切回自动模式　switch to the passive mode, and will be automatically switch back to catchall mode if no more controll has been send to libraf *
    """
    pass

  def IsBlocking(self):
    """
    系统是否正忙　if system is blocked to recieve any commend from client *
    """
    pass

  def SetIRCut(self, is_ir_on):
    """
    close the IRcut (ir will be filtered), if is_ir_on is true *

    Parameters:
     - is_ir_on
    """
    pass

  def GetIRCut(self):
    """
    get true if the IRcut is close (ir is filtered) *
    """
    pass

  def SetDayNight(self, interval):
    """
    Parameters:
     - interval
    """
    pass

  def GetDayNight(self):
    pass

  def GetRawImg(self, sensor_type):
    """
    获取长焦/广角小尺寸图　get a encoded frame as a string from the wide view or the long focus camera *

    Parameters:
     - sensor_type
    """
    pass

  def GetStreamImg(self):
    """
    获取视频流图片　get a encoded frame as a string of the video stream *
    """
    pass

  def GetFullSzRawImg(self, sensor_type):
    """
    获取长焦/广角原尺寸图　get a encoded jpeg image with original size from the wide view or the long focus camera *

    Parameters:
     - sensor_type
    """
    pass

  def GetUndistortWideImg(self, undistort_type):
    """
    获取广角去畸变　get a undistort frame from wide camera*

    Parameters:
     - undistort_type
    """
    pass

  def GetSensorProperties(self, sensor_type):
    """
    get sensor properties *

    Parameters:
     - sensor_type
    """
    pass

  def SetSensorProperties(self, sensor_type, sensor_prop):
    """
    set sensor properties, return false if failed to set sensor properties *

    Parameters:
     - sensor_type
     - sensor_prop
    """
    pass

  def SetIrisOffset(self, sensor_type, offset):
    """
    设置相机光圈电压值　*

    Parameters:
     - sensor_type
     - offset
    """
    pass

  def GetIrisOffset(self, sensor_type):
    """
    Parameters:
     - sensor_type
    """
    pass

  def GetMotorProperties(self):
    """
    未实现　get motor properties *
    """
    pass

  def SetMotorProperties(self, motor_prop):
    """
    未实现　set motor properties, return false if failed to set motor properties *

    Parameters:
     - motor_prop
    """
    pass

  def SetLookAtPointOnStream(self, point):
    """
    在视频流上指哪打哪　look at the point refer to the streaming coordinate system *

    Parameters:
     - point
    """
    pass

  def MoveLookAtPointOnStream(self, point):
    """
    在广角画面中移动聚焦位置　move the look at point with the vector "RpcPoint& point" refer to the streaming coordinate system *

    Parameters:
     - point
    """
    pass

  def SetLookAtPoint(self, point):
    """
    在广角画面上指哪打哪　look at the point refer to the original image coordinate system *

    Parameters:
     - point
    """
    pass

  def RotateMotorSmallStep(self, rot_type, nsteps):
    """
    直接控制电机（输入单位为电机编码器精度）　directly rotate the view of long focus camera *

    Parameters:
     - rot_type
     - nsteps
    """
    pass

  def RotateMotorWithGivenStepLevel(self, rot_type, level):
    """
    直接控制电机（输入单位为预定大小）　directly rotate the view of long focus camera *

    Parameters:
     - rot_type
     - level
    """
    pass

  def ResetMotor(self):
    """
    转动至初始位置　Reset the motor to the original position *
    """
    pass

  def SetLayoutProperties(self, layout_prop):
    """
    set layout properties *

    Parameters:
     - layout_prop
    """
    pass

  def GetLayoutProperties(self):
    """
    get layout properties *
    """
    pass

  def SetSmartStreamType(self, smart_stream_type):
    """
    set/get the type of smart streaming properties *

    Parameters:
     - smart_stream_type
    """
    pass

  def GetSmartStreamType(self):
    pass

  def SetStreamProperties(self, stream_type, stream_prop):
    """
    无用　set streaming properties *

    Parameters:
     - stream_type
     - stream_prop
    """
    pass

  def GetStreamProperties(self, stream_type):
    """
    无用　get streaming properties *

    Parameters:
     - stream_type
    """
    pass

  def SetTwoStreamProperties(self, stream_prop):
    """
    set both streaming properties *

    Parameters:
     - stream_prop
    """
    pass

  def GetTwoStreamProperties(self):
    """
    get both streaming properties *
    """
    pass

  def SetDetectionProperties(self, det_roi):
    """
    set detection properties, throw error if failed to set detection properties *

    Parameters:
     - det_roi
    """
    pass

  def GetDetectionProperties(self):
    """
    get detection properties *
    """
    pass

  def SetImageMasks(self, img_masks):
    """
    set image masks, false mask is over the boundary of image *

    Parameters:
     - img_masks
    """
    pass

  def GetImageMasks(self):
    """
    get detection properties *
    """
    pass

  def SetMaskOn(self, is_mask_on):
    """
    打开图像遮盖功能　image masks will be implemented if is_mask_on is true *

    Parameters:
     - is_mask_on
    """
    pass

  def GetMaskOn(self):
    """
    获取图像遮盖功能状态　get true if image masks has been implemented *
    """
    pass

  def Calibrate(self, is_auto):
    """
    do calibration includes two modes:
    1. (is_auto = true) automatically align centers and calibrate
    2. (is_auto = false) automatically calibrate but munually align centers throught SetLookAtPoint before implementation of it *

    Parameters:
     - is_auto
    """
    pass

  def StopCali(self):
    """
    中断自动校准　force to stop calibration: *
    """
    pass

  def CaliBusy(self):
    """
    是否正在自动校准　if calibration is running *
    """
    pass

  def CaliState(self):
    """
    校准完成进度　read the completeness of calibration (0 - 100), -1 denotes failed *
    """
    pass

  def GetAlignROI(self):
    """
    校准开始前长焦画面应当在广角画面中的位置　get the roi of the wide view into which the long view should be aligned *
    """
    pass

  def LearnBGM(self):
    """
    learn BGM *
    """
    pass

  def LearnBGMState(self):
    """
    read the completeness of learning bgm (0 - 100) *
    """
    pass

  def GetBGMSensitivity(self):
    """
    get BGM sensitivity *
    """
    pass

  def SetBGMSensitivity(self, sen):
    """
    set BGM sensitivity, return false if failed to set sensitivity (0-255 float)*

    Parameters:
     - sen
    """
    pass

  def SetFontProperties(self, text_type, font_prop):
    """
    Parameters:
     - text_type
     - font_prop
    """
    pass

  def GetFontProperties(self, text_type):
    """
    Parameters:
     - text_type
    """
    pass

  def SetOSDOthers(self, osd_other):
    """
    set the status of other display details (24-hour time, show display and channel string) *

    Parameters:
     - osd_other
    """
    pass

  def GetOSDOthers(self):
    """
    get the status of other display details (24-hour time, show display and channel string) *
    """
    pass

  def SetTextAlign(self, text_type, align_type):
    """
    set the type of text alignment *

    Parameters:
     - text_type
     - align_type
    """
    pass

  def GetTextAlign(self, text_type):
    """
    get the type of text alignment *

    Parameters:
     - text_type
    """
    pass

  def SetDrawBBS(self, is_draw_bbs_):
    """
    在视频中画出检测框 *

    Parameters:
     - is_draw_bbs_
    """
    pass

  def GetDrawBBS(self):
    pass

  def SetDrawView(self, is_draw_view_):
    """
    Parameters:
     - is_draw_view_
    """
    pass

  def GetDrawView(self):
    pass

  def SetDrawDetGrid(self, is_draw_):
    """
    Parameters:
     - is_draw_
    """
    pass

  def GetDrawDetGrid(self):
    pass

  def SetDetTasks(self, snap_type):
    """
    设置检测功能列表　enable the the corresponding detection tasks *

    Parameters:
     - snap_type
    """
    pass

  def GetDetTasks(self):
    """
    get the list of detection tasks *
    """
    pass

  def SetSnapProps(self, snap_props):
    """
    Parameters:
     - snap_props
    """
    pass

  def GetSnapProps(self):
    pass

  def GetSnapConnectionInfo(self):
    pass

  def GetSnapPublicKey(self):
    pass

  def ResetSnapPriveteKey(self):
    pass

  def SetCompatible(self, compatible):
    """
    Parameters:
     - compatible
    """
    pass

  def GetCompatible(self):
    pass

  def SetImgTransProperties(self, snap_type, img_trans_prop):
    """
    set the img transfer properties *

    Parameters:
     - snap_type
     - img_trans_prop
    """
    pass

  def GetImgTransProperties(self, snap_type):
    """
    get the img transfer properties *

    Parameters:
     - snap_type
    """
    pass

  def SetImgTransList(self, snap_type):
    """
    配置图传类型列表　enable the img transfer task of the corresponding tasks *

    Parameters:
     - snap_type
    """
    pass

  def GetImgTransList(self):
    """
    get the list img transfer tasks *
    """
    pass

  def SaveParam(self):
    """
    save to local file *
    """
    pass

  def LoadParam(self):
    """
    read from local file *
    """
    pass

  def StartLibraF(self):
    pass

  def StopLibraF(self):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def Stop(self):
    self.send_Stop()
    self.recv_Stop()

  def send_Stop(self):
    self._oprot.writeMessageBegin('Stop', TMessageType.CALL, self._seqid)
    args = Stop_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_Stop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = Stop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetWorkMode(self):
    """
    获取工作模式　get work mode *
    """
    self.send_GetWorkMode()
    return self.recv_GetWorkMode()

  def send_GetWorkMode(self):
    self._oprot.writeMessageBegin('GetWorkMode', TMessageType.CALL, self._seqid)
    args = GetWorkMode_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetWorkMode(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetWorkMode_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkMode failed: unknown result")

  def SetWorkMode(self, work_mode):
    """
    设置工作模式　set work mode, return false if failed to switch work mode *

    Parameters:
     - work_mode
    """
    self.send_SetWorkMode(work_mode)
    self.recv_SetWorkMode()

  def send_SetWorkMode(self, work_mode):
    self._oprot.writeMessageBegin('SetWorkMode', TMessageType.CALL, self._seqid)
    args = SetWorkMode_args()
    args.work_mode = work_mode
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetWorkMode(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetWorkMode_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def SwitchToPassiveModeWithTimer(self):
    """
    切换到手动模式，一段时间不进行操作则自动切回自动模式　switch to the passive mode, and will be automatically switch back to catchall mode if no more controll has been send to libraf *
    """
    self.send_SwitchToPassiveModeWithTimer()
    self.recv_SwitchToPassiveModeWithTimer()

  def send_SwitchToPassiveModeWithTimer(self):
    self._oprot.writeMessageBegin('SwitchToPassiveModeWithTimer', TMessageType.CALL, self._seqid)
    args = SwitchToPassiveModeWithTimer_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SwitchToPassiveModeWithTimer(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SwitchToPassiveModeWithTimer_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def IsBlocking(self):
    """
    系统是否正忙　if system is blocked to recieve any commend from client *
    """
    self.send_IsBlocking()
    return self.recv_IsBlocking()

  def send_IsBlocking(self):
    self._oprot.writeMessageBegin('IsBlocking', TMessageType.CALL, self._seqid)
    args = IsBlocking_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsBlocking(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = IsBlocking_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsBlocking failed: unknown result")

  def SetIRCut(self, is_ir_on):
    """
    close the IRcut (ir will be filtered), if is_ir_on is true *

    Parameters:
     - is_ir_on
    """
    self.send_SetIRCut(is_ir_on)
    self.recv_SetIRCut()

  def send_SetIRCut(self, is_ir_on):
    self._oprot.writeMessageBegin('SetIRCut', TMessageType.CALL, self._seqid)
    args = SetIRCut_args()
    args.is_ir_on = is_ir_on
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetIRCut(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetIRCut_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetIRCut(self):
    """
    get true if the IRcut is close (ir is filtered) *
    """
    self.send_GetIRCut()
    return self.recv_GetIRCut()

  def send_GetIRCut(self):
    self._oprot.writeMessageBegin('GetIRCut', TMessageType.CALL, self._seqid)
    args = GetIRCut_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetIRCut(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetIRCut_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetIRCut failed: unknown result")

  def SetDayNight(self, interval):
    """
    Parameters:
     - interval
    """
    self.send_SetDayNight(interval)
    self.recv_SetDayNight()

  def send_SetDayNight(self, interval):
    self._oprot.writeMessageBegin('SetDayNight', TMessageType.CALL, self._seqid)
    args = SetDayNight_args()
    args.interval = interval
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetDayNight(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetDayNight_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetDayNight(self):
    self.send_GetDayNight()
    return self.recv_GetDayNight()

  def send_GetDayNight(self):
    self._oprot.writeMessageBegin('GetDayNight', TMessageType.CALL, self._seqid)
    args = GetDayNight_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetDayNight(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetDayNight_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDayNight failed: unknown result")

  def GetRawImg(self, sensor_type):
    """
    获取长焦/广角小尺寸图　get a encoded frame as a string from the wide view or the long focus camera *

    Parameters:
     - sensor_type
    """
    self.send_GetRawImg(sensor_type)
    return self.recv_GetRawImg()

  def send_GetRawImg(self, sensor_type):
    self._oprot.writeMessageBegin('GetRawImg', TMessageType.CALL, self._seqid)
    args = GetRawImg_args()
    args.sensor_type = sensor_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetRawImg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetRawImg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetRawImg failed: unknown result")

  def GetStreamImg(self):
    """
    获取视频流图片　get a encoded frame as a string of the video stream *
    """
    self.send_GetStreamImg()
    return self.recv_GetStreamImg()

  def send_GetStreamImg(self):
    self._oprot.writeMessageBegin('GetStreamImg', TMessageType.CALL, self._seqid)
    args = GetStreamImg_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetStreamImg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetStreamImg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStreamImg failed: unknown result")

  def GetFullSzRawImg(self, sensor_type):
    """
    获取长焦/广角原尺寸图　get a encoded jpeg image with original size from the wide view or the long focus camera *

    Parameters:
     - sensor_type
    """
    self.send_GetFullSzRawImg(sensor_type)
    return self.recv_GetFullSzRawImg()

  def send_GetFullSzRawImg(self, sensor_type):
    self._oprot.writeMessageBegin('GetFullSzRawImg', TMessageType.CALL, self._seqid)
    args = GetFullSzRawImg_args()
    args.sensor_type = sensor_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetFullSzRawImg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetFullSzRawImg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetFullSzRawImg failed: unknown result")

  def GetUndistortWideImg(self, undistort_type):
    """
    获取广角去畸变　get a undistort frame from wide camera*

    Parameters:
     - undistort_type
    """
    self.send_GetUndistortWideImg(undistort_type)
    return self.recv_GetUndistortWideImg()

  def send_GetUndistortWideImg(self, undistort_type):
    self._oprot.writeMessageBegin('GetUndistortWideImg', TMessageType.CALL, self._seqid)
    args = GetUndistortWideImg_args()
    args.undistort_type = undistort_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetUndistortWideImg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetUndistortWideImg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetUndistortWideImg failed: unknown result")

  def GetSensorProperties(self, sensor_type):
    """
    get sensor properties *

    Parameters:
     - sensor_type
    """
    self.send_GetSensorProperties(sensor_type)
    return self.recv_GetSensorProperties()

  def send_GetSensorProperties(self, sensor_type):
    self._oprot.writeMessageBegin('GetSensorProperties', TMessageType.CALL, self._seqid)
    args = GetSensorProperties_args()
    args.sensor_type = sensor_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSensorProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetSensorProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSensorProperties failed: unknown result")

  def SetSensorProperties(self, sensor_type, sensor_prop):
    """
    set sensor properties, return false if failed to set sensor properties *

    Parameters:
     - sensor_type
     - sensor_prop
    """
    self.send_SetSensorProperties(sensor_type, sensor_prop)
    self.recv_SetSensorProperties()

  def send_SetSensorProperties(self, sensor_type, sensor_prop):
    self._oprot.writeMessageBegin('SetSensorProperties', TMessageType.CALL, self._seqid)
    args = SetSensorProperties_args()
    args.sensor_type = sensor_type
    args.sensor_prop = sensor_prop
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSensorProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetSensorProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def SetIrisOffset(self, sensor_type, offset):
    """
    设置相机光圈电压值　*

    Parameters:
     - sensor_type
     - offset
    """
    self.send_SetIrisOffset(sensor_type, offset)
    self.recv_SetIrisOffset()

  def send_SetIrisOffset(self, sensor_type, offset):
    self._oprot.writeMessageBegin('SetIrisOffset', TMessageType.CALL, self._seqid)
    args = SetIrisOffset_args()
    args.sensor_type = sensor_type
    args.offset = offset
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetIrisOffset(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetIrisOffset_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetIrisOffset(self, sensor_type):
    """
    Parameters:
     - sensor_type
    """
    self.send_GetIrisOffset(sensor_type)
    return self.recv_GetIrisOffset()

  def send_GetIrisOffset(self, sensor_type):
    self._oprot.writeMessageBegin('GetIrisOffset', TMessageType.CALL, self._seqid)
    args = GetIrisOffset_args()
    args.sensor_type = sensor_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetIrisOffset(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetIrisOffset_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetIrisOffset failed: unknown result")

  def GetMotorProperties(self):
    """
    未实现　get motor properties *
    """
    self.send_GetMotorProperties()
    return self.recv_GetMotorProperties()

  def send_GetMotorProperties(self):
    self._oprot.writeMessageBegin('GetMotorProperties', TMessageType.CALL, self._seqid)
    args = GetMotorProperties_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetMotorProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetMotorProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetMotorProperties failed: unknown result")

  def SetMotorProperties(self, motor_prop):
    """
    未实现　set motor properties, return false if failed to set motor properties *

    Parameters:
     - motor_prop
    """
    self.send_SetMotorProperties(motor_prop)
    self.recv_SetMotorProperties()

  def send_SetMotorProperties(self, motor_prop):
    self._oprot.writeMessageBegin('SetMotorProperties', TMessageType.CALL, self._seqid)
    args = SetMotorProperties_args()
    args.motor_prop = motor_prop
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetMotorProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetMotorProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def SetLookAtPointOnStream(self, point):
    """
    在视频流上指哪打哪　look at the point refer to the streaming coordinate system *

    Parameters:
     - point
    """
    self.send_SetLookAtPointOnStream(point)
    self.recv_SetLookAtPointOnStream()

  def send_SetLookAtPointOnStream(self, point):
    self._oprot.writeMessageBegin('SetLookAtPointOnStream', TMessageType.CALL, self._seqid)
    args = SetLookAtPointOnStream_args()
    args.point = point
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetLookAtPointOnStream(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetLookAtPointOnStream_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def MoveLookAtPointOnStream(self, point):
    """
    在广角画面中移动聚焦位置　move the look at point with the vector "RpcPoint& point" refer to the streaming coordinate system *

    Parameters:
     - point
    """
    self.send_MoveLookAtPointOnStream(point)
    self.recv_MoveLookAtPointOnStream()

  def send_MoveLookAtPointOnStream(self, point):
    self._oprot.writeMessageBegin('MoveLookAtPointOnStream', TMessageType.CALL, self._seqid)
    args = MoveLookAtPointOnStream_args()
    args.point = point
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_MoveLookAtPointOnStream(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = MoveLookAtPointOnStream_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def SetLookAtPoint(self, point):
    """
    在广角画面上指哪打哪　look at the point refer to the original image coordinate system *

    Parameters:
     - point
    """
    self.send_SetLookAtPoint(point)
    self.recv_SetLookAtPoint()

  def send_SetLookAtPoint(self, point):
    self._oprot.writeMessageBegin('SetLookAtPoint', TMessageType.CALL, self._seqid)
    args = SetLookAtPoint_args()
    args.point = point
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetLookAtPoint(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetLookAtPoint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def RotateMotorSmallStep(self, rot_type, nsteps):
    """
    直接控制电机（输入单位为电机编码器精度）　directly rotate the view of long focus camera *

    Parameters:
     - rot_type
     - nsteps
    """
    self.send_RotateMotorSmallStep(rot_type, nsteps)
    self.recv_RotateMotorSmallStep()

  def send_RotateMotorSmallStep(self, rot_type, nsteps):
    self._oprot.writeMessageBegin('RotateMotorSmallStep', TMessageType.CALL, self._seqid)
    args = RotateMotorSmallStep_args()
    args.rot_type = rot_type
    args.nsteps = nsteps
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RotateMotorSmallStep(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RotateMotorSmallStep_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def RotateMotorWithGivenStepLevel(self, rot_type, level):
    """
    直接控制电机（输入单位为预定大小）　directly rotate the view of long focus camera *

    Parameters:
     - rot_type
     - level
    """
    self.send_RotateMotorWithGivenStepLevel(rot_type, level)
    self.recv_RotateMotorWithGivenStepLevel()

  def send_RotateMotorWithGivenStepLevel(self, rot_type, level):
    self._oprot.writeMessageBegin('RotateMotorWithGivenStepLevel', TMessageType.CALL, self._seqid)
    args = RotateMotorWithGivenStepLevel_args()
    args.rot_type = rot_type
    args.level = level
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RotateMotorWithGivenStepLevel(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RotateMotorWithGivenStepLevel_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def ResetMotor(self):
    """
    转动至初始位置　Reset the motor to the original position *
    """
    self.send_ResetMotor()
    self.recv_ResetMotor()

  def send_ResetMotor(self):
    self._oprot.writeMessageBegin('ResetMotor', TMessageType.CALL, self._seqid)
    args = ResetMotor_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ResetMotor(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ResetMotor_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def SetLayoutProperties(self, layout_prop):
    """
    set layout properties *

    Parameters:
     - layout_prop
    """
    self.send_SetLayoutProperties(layout_prop)
    self.recv_SetLayoutProperties()

  def send_SetLayoutProperties(self, layout_prop):
    self._oprot.writeMessageBegin('SetLayoutProperties', TMessageType.CALL, self._seqid)
    args = SetLayoutProperties_args()
    args.layout_prop = layout_prop
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetLayoutProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetLayoutProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetLayoutProperties(self):
    """
    get layout properties *
    """
    self.send_GetLayoutProperties()
    return self.recv_GetLayoutProperties()

  def send_GetLayoutProperties(self):
    self._oprot.writeMessageBegin('GetLayoutProperties', TMessageType.CALL, self._seqid)
    args = GetLayoutProperties_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetLayoutProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetLayoutProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLayoutProperties failed: unknown result")

  def SetSmartStreamType(self, smart_stream_type):
    """
    set/get the type of smart streaming properties *

    Parameters:
     - smart_stream_type
    """
    self.send_SetSmartStreamType(smart_stream_type)
    self.recv_SetSmartStreamType()

  def send_SetSmartStreamType(self, smart_stream_type):
    self._oprot.writeMessageBegin('SetSmartStreamType', TMessageType.CALL, self._seqid)
    args = SetSmartStreamType_args()
    args.smart_stream_type = smart_stream_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSmartStreamType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetSmartStreamType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetSmartStreamType(self):
    self.send_GetSmartStreamType()
    return self.recv_GetSmartStreamType()

  def send_GetSmartStreamType(self):
    self._oprot.writeMessageBegin('GetSmartStreamType', TMessageType.CALL, self._seqid)
    args = GetSmartStreamType_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSmartStreamType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetSmartStreamType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSmartStreamType failed: unknown result")

  def SetStreamProperties(self, stream_type, stream_prop):
    """
    无用　set streaming properties *

    Parameters:
     - stream_type
     - stream_prop
    """
    self.send_SetStreamProperties(stream_type, stream_prop)
    self.recv_SetStreamProperties()

  def send_SetStreamProperties(self, stream_type, stream_prop):
    self._oprot.writeMessageBegin('SetStreamProperties', TMessageType.CALL, self._seqid)
    args = SetStreamProperties_args()
    args.stream_type = stream_type
    args.stream_prop = stream_prop
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetStreamProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetStreamProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetStreamProperties(self, stream_type):
    """
    无用　get streaming properties *

    Parameters:
     - stream_type
    """
    self.send_GetStreamProperties(stream_type)
    return self.recv_GetStreamProperties()

  def send_GetStreamProperties(self, stream_type):
    self._oprot.writeMessageBegin('GetStreamProperties', TMessageType.CALL, self._seqid)
    args = GetStreamProperties_args()
    args.stream_type = stream_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetStreamProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetStreamProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStreamProperties failed: unknown result")

  def SetTwoStreamProperties(self, stream_prop):
    """
    set both streaming properties *

    Parameters:
     - stream_prop
    """
    self.send_SetTwoStreamProperties(stream_prop)
    self.recv_SetTwoStreamProperties()

  def send_SetTwoStreamProperties(self, stream_prop):
    self._oprot.writeMessageBegin('SetTwoStreamProperties', TMessageType.CALL, self._seqid)
    args = SetTwoStreamProperties_args()
    args.stream_prop = stream_prop
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetTwoStreamProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetTwoStreamProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetTwoStreamProperties(self):
    """
    get both streaming properties *
    """
    self.send_GetTwoStreamProperties()
    return self.recv_GetTwoStreamProperties()

  def send_GetTwoStreamProperties(self):
    self._oprot.writeMessageBegin('GetTwoStreamProperties', TMessageType.CALL, self._seqid)
    args = GetTwoStreamProperties_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetTwoStreamProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetTwoStreamProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetTwoStreamProperties failed: unknown result")

  def SetDetectionProperties(self, det_roi):
    """
    set detection properties, throw error if failed to set detection properties *

    Parameters:
     - det_roi
    """
    self.send_SetDetectionProperties(det_roi)
    self.recv_SetDetectionProperties()

  def send_SetDetectionProperties(self, det_roi):
    self._oprot.writeMessageBegin('SetDetectionProperties', TMessageType.CALL, self._seqid)
    args = SetDetectionProperties_args()
    args.det_roi = det_roi
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetDetectionProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetDetectionProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetDetectionProperties(self):
    """
    get detection properties *
    """
    self.send_GetDetectionProperties()
    return self.recv_GetDetectionProperties()

  def send_GetDetectionProperties(self):
    self._oprot.writeMessageBegin('GetDetectionProperties', TMessageType.CALL, self._seqid)
    args = GetDetectionProperties_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetDetectionProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetDetectionProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDetectionProperties failed: unknown result")

  def SetImageMasks(self, img_masks):
    """
    set image masks, false mask is over the boundary of image *

    Parameters:
     - img_masks
    """
    self.send_SetImageMasks(img_masks)
    self.recv_SetImageMasks()

  def send_SetImageMasks(self, img_masks):
    self._oprot.writeMessageBegin('SetImageMasks', TMessageType.CALL, self._seqid)
    args = SetImageMasks_args()
    args.img_masks = img_masks
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetImageMasks(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetImageMasks_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetImageMasks(self):
    """
    get detection properties *
    """
    self.send_GetImageMasks()
    return self.recv_GetImageMasks()

  def send_GetImageMasks(self):
    self._oprot.writeMessageBegin('GetImageMasks', TMessageType.CALL, self._seqid)
    args = GetImageMasks_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetImageMasks(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetImageMasks_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetImageMasks failed: unknown result")

  def SetMaskOn(self, is_mask_on):
    """
    打开图像遮盖功能　image masks will be implemented if is_mask_on is true *

    Parameters:
     - is_mask_on
    """
    self.send_SetMaskOn(is_mask_on)
    self.recv_SetMaskOn()

  def send_SetMaskOn(self, is_mask_on):
    self._oprot.writeMessageBegin('SetMaskOn', TMessageType.CALL, self._seqid)
    args = SetMaskOn_args()
    args.is_mask_on = is_mask_on
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetMaskOn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetMaskOn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetMaskOn(self):
    """
    获取图像遮盖功能状态　get true if image masks has been implemented *
    """
    self.send_GetMaskOn()
    return self.recv_GetMaskOn()

  def send_GetMaskOn(self):
    self._oprot.writeMessageBegin('GetMaskOn', TMessageType.CALL, self._seqid)
    args = GetMaskOn_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetMaskOn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetMaskOn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetMaskOn failed: unknown result")

  def Calibrate(self, is_auto):
    """
    do calibration includes two modes:
    1. (is_auto = true) automatically align centers and calibrate
    2. (is_auto = false) automatically calibrate but munually align centers throught SetLookAtPoint before implementation of it *

    Parameters:
     - is_auto
    """
    self.send_Calibrate(is_auto)
    self.recv_Calibrate()

  def send_Calibrate(self, is_auto):
    self._oprot.writeMessageBegin('Calibrate', TMessageType.CALL, self._seqid)
    args = Calibrate_args()
    args.is_auto = is_auto
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_Calibrate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = Calibrate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def StopCali(self):
    """
    中断自动校准　force to stop calibration: *
    """
    self.send_StopCali()
    self.recv_StopCali()

  def send_StopCali(self):
    self._oprot.writeMessageBegin('StopCali', TMessageType.CALL, self._seqid)
    args = StopCali_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_StopCali(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = StopCali_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def CaliBusy(self):
    """
    是否正在自动校准　if calibration is running *
    """
    self.send_CaliBusy()
    return self.recv_CaliBusy()

  def send_CaliBusy(self):
    self._oprot.writeMessageBegin('CaliBusy', TMessageType.CALL, self._seqid)
    args = CaliBusy_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CaliBusy(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CaliBusy_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CaliBusy failed: unknown result")

  def CaliState(self):
    """
    校准完成进度　read the completeness of calibration (0 - 100), -1 denotes failed *
    """
    self.send_CaliState()
    return self.recv_CaliState()

  def send_CaliState(self):
    self._oprot.writeMessageBegin('CaliState', TMessageType.CALL, self._seqid)
    args = CaliState_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CaliState(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CaliState_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CaliState failed: unknown result")

  def GetAlignROI(self):
    """
    校准开始前长焦画面应当在广角画面中的位置　get the roi of the wide view into which the long view should be aligned *
    """
    self.send_GetAlignROI()
    return self.recv_GetAlignROI()

  def send_GetAlignROI(self):
    self._oprot.writeMessageBegin('GetAlignROI', TMessageType.CALL, self._seqid)
    args = GetAlignROI_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAlignROI(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetAlignROI_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAlignROI failed: unknown result")

  def LearnBGM(self):
    """
    learn BGM *
    """
    self.send_LearnBGM()
    self.recv_LearnBGM()

  def send_LearnBGM(self):
    self._oprot.writeMessageBegin('LearnBGM', TMessageType.CALL, self._seqid)
    args = LearnBGM_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LearnBGM(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LearnBGM_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def LearnBGMState(self):
    """
    read the completeness of learning bgm (0 - 100) *
    """
    self.send_LearnBGMState()
    return self.recv_LearnBGMState()

  def send_LearnBGMState(self):
    self._oprot.writeMessageBegin('LearnBGMState', TMessageType.CALL, self._seqid)
    args = LearnBGMState_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LearnBGMState(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LearnBGMState_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "LearnBGMState failed: unknown result")

  def GetBGMSensitivity(self):
    """
    get BGM sensitivity *
    """
    self.send_GetBGMSensitivity()
    return self.recv_GetBGMSensitivity()

  def send_GetBGMSensitivity(self):
    self._oprot.writeMessageBegin('GetBGMSensitivity', TMessageType.CALL, self._seqid)
    args = GetBGMSensitivity_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetBGMSensitivity(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetBGMSensitivity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetBGMSensitivity failed: unknown result")

  def SetBGMSensitivity(self, sen):
    """
    set BGM sensitivity, return false if failed to set sensitivity (0-255 float)*

    Parameters:
     - sen
    """
    self.send_SetBGMSensitivity(sen)
    self.recv_SetBGMSensitivity()

  def send_SetBGMSensitivity(self, sen):
    self._oprot.writeMessageBegin('SetBGMSensitivity', TMessageType.CALL, self._seqid)
    args = SetBGMSensitivity_args()
    args.sen = sen
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetBGMSensitivity(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetBGMSensitivity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def SetFontProperties(self, text_type, font_prop):
    """
    Parameters:
     - text_type
     - font_prop
    """
    self.send_SetFontProperties(text_type, font_prop)
    self.recv_SetFontProperties()

  def send_SetFontProperties(self, text_type, font_prop):
    self._oprot.writeMessageBegin('SetFontProperties', TMessageType.CALL, self._seqid)
    args = SetFontProperties_args()
    args.text_type = text_type
    args.font_prop = font_prop
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetFontProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetFontProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetFontProperties(self, text_type):
    """
    Parameters:
     - text_type
    """
    self.send_GetFontProperties(text_type)
    return self.recv_GetFontProperties()

  def send_GetFontProperties(self, text_type):
    self._oprot.writeMessageBegin('GetFontProperties', TMessageType.CALL, self._seqid)
    args = GetFontProperties_args()
    args.text_type = text_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetFontProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetFontProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetFontProperties failed: unknown result")

  def SetOSDOthers(self, osd_other):
    """
    set the status of other display details (24-hour time, show display and channel string) *

    Parameters:
     - osd_other
    """
    self.send_SetOSDOthers(osd_other)
    self.recv_SetOSDOthers()

  def send_SetOSDOthers(self, osd_other):
    self._oprot.writeMessageBegin('SetOSDOthers', TMessageType.CALL, self._seqid)
    args = SetOSDOthers_args()
    args.osd_other = osd_other
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetOSDOthers(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetOSDOthers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetOSDOthers(self):
    """
    get the status of other display details (24-hour time, show display and channel string) *
    """
    self.send_GetOSDOthers()
    return self.recv_GetOSDOthers()

  def send_GetOSDOthers(self):
    self._oprot.writeMessageBegin('GetOSDOthers', TMessageType.CALL, self._seqid)
    args = GetOSDOthers_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetOSDOthers(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetOSDOthers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetOSDOthers failed: unknown result")

  def SetTextAlign(self, text_type, align_type):
    """
    set the type of text alignment *

    Parameters:
     - text_type
     - align_type
    """
    self.send_SetTextAlign(text_type, align_type)
    self.recv_SetTextAlign()

  def send_SetTextAlign(self, text_type, align_type):
    self._oprot.writeMessageBegin('SetTextAlign', TMessageType.CALL, self._seqid)
    args = SetTextAlign_args()
    args.text_type = text_type
    args.align_type = align_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetTextAlign(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetTextAlign_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetTextAlign(self, text_type):
    """
    get the type of text alignment *

    Parameters:
     - text_type
    """
    self.send_GetTextAlign(text_type)
    return self.recv_GetTextAlign()

  def send_GetTextAlign(self, text_type):
    self._oprot.writeMessageBegin('GetTextAlign', TMessageType.CALL, self._seqid)
    args = GetTextAlign_args()
    args.text_type = text_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetTextAlign(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetTextAlign_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetTextAlign failed: unknown result")

  def SetDrawBBS(self, is_draw_bbs_):
    """
    在视频中画出检测框 *

    Parameters:
     - is_draw_bbs_
    """
    self.send_SetDrawBBS(is_draw_bbs_)
    self.recv_SetDrawBBS()

  def send_SetDrawBBS(self, is_draw_bbs_):
    self._oprot.writeMessageBegin('SetDrawBBS', TMessageType.CALL, self._seqid)
    args = SetDrawBBS_args()
    args.is_draw_bbs_ = is_draw_bbs_
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetDrawBBS(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetDrawBBS_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetDrawBBS(self):
    self.send_GetDrawBBS()
    return self.recv_GetDrawBBS()

  def send_GetDrawBBS(self):
    self._oprot.writeMessageBegin('GetDrawBBS', TMessageType.CALL, self._seqid)
    args = GetDrawBBS_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetDrawBBS(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetDrawBBS_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDrawBBS failed: unknown result")

  def SetDrawView(self, is_draw_view_):
    """
    Parameters:
     - is_draw_view_
    """
    self.send_SetDrawView(is_draw_view_)
    self.recv_SetDrawView()

  def send_SetDrawView(self, is_draw_view_):
    self._oprot.writeMessageBegin('SetDrawView', TMessageType.CALL, self._seqid)
    args = SetDrawView_args()
    args.is_draw_view_ = is_draw_view_
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetDrawView(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetDrawView_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetDrawView(self):
    self.send_GetDrawView()
    return self.recv_GetDrawView()

  def send_GetDrawView(self):
    self._oprot.writeMessageBegin('GetDrawView', TMessageType.CALL, self._seqid)
    args = GetDrawView_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetDrawView(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetDrawView_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDrawView failed: unknown result")

  def SetDrawDetGrid(self, is_draw_):
    """
    Parameters:
     - is_draw_
    """
    self.send_SetDrawDetGrid(is_draw_)
    self.recv_SetDrawDetGrid()

  def send_SetDrawDetGrid(self, is_draw_):
    self._oprot.writeMessageBegin('SetDrawDetGrid', TMessageType.CALL, self._seqid)
    args = SetDrawDetGrid_args()
    args.is_draw_ = is_draw_
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetDrawDetGrid(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetDrawDetGrid_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetDrawDetGrid(self):
    self.send_GetDrawDetGrid()
    return self.recv_GetDrawDetGrid()

  def send_GetDrawDetGrid(self):
    self._oprot.writeMessageBegin('GetDrawDetGrid', TMessageType.CALL, self._seqid)
    args = GetDrawDetGrid_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetDrawDetGrid(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetDrawDetGrid_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDrawDetGrid failed: unknown result")

  def SetDetTasks(self, snap_type):
    """
    设置检测功能列表　enable the the corresponding detection tasks *

    Parameters:
     - snap_type
    """
    self.send_SetDetTasks(snap_type)
    self.recv_SetDetTasks()

  def send_SetDetTasks(self, snap_type):
    self._oprot.writeMessageBegin('SetDetTasks', TMessageType.CALL, self._seqid)
    args = SetDetTasks_args()
    args.snap_type = snap_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetDetTasks(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetDetTasks_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetDetTasks(self):
    """
    get the list of detection tasks *
    """
    self.send_GetDetTasks()
    return self.recv_GetDetTasks()

  def send_GetDetTasks(self):
    self._oprot.writeMessageBegin('GetDetTasks', TMessageType.CALL, self._seqid)
    args = GetDetTasks_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetDetTasks(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetDetTasks_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDetTasks failed: unknown result")

  def SetSnapProps(self, snap_props):
    """
    Parameters:
     - snap_props
    """
    self.send_SetSnapProps(snap_props)
    self.recv_SetSnapProps()

  def send_SetSnapProps(self, snap_props):
    self._oprot.writeMessageBegin('SetSnapProps', TMessageType.CALL, self._seqid)
    args = SetSnapProps_args()
    args.snap_props = snap_props
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetSnapProps(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetSnapProps_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetSnapProps(self):
    self.send_GetSnapProps()
    return self.recv_GetSnapProps()

  def send_GetSnapProps(self):
    self._oprot.writeMessageBegin('GetSnapProps', TMessageType.CALL, self._seqid)
    args = GetSnapProps_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSnapProps(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetSnapProps_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSnapProps failed: unknown result")

  def GetSnapConnectionInfo(self):
    self.send_GetSnapConnectionInfo()
    return self.recv_GetSnapConnectionInfo()

  def send_GetSnapConnectionInfo(self):
    self._oprot.writeMessageBegin('GetSnapConnectionInfo', TMessageType.CALL, self._seqid)
    args = GetSnapConnectionInfo_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSnapConnectionInfo(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetSnapConnectionInfo_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSnapConnectionInfo failed: unknown result")

  def GetSnapPublicKey(self):
    self.send_GetSnapPublicKey()
    return self.recv_GetSnapPublicKey()

  def send_GetSnapPublicKey(self):
    self._oprot.writeMessageBegin('GetSnapPublicKey', TMessageType.CALL, self._seqid)
    args = GetSnapPublicKey_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetSnapPublicKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetSnapPublicKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSnapPublicKey failed: unknown result")

  def ResetSnapPriveteKey(self):
    self.send_ResetSnapPriveteKey()
    return self.recv_ResetSnapPriveteKey()

  def send_ResetSnapPriveteKey(self):
    self._oprot.writeMessageBegin('ResetSnapPriveteKey', TMessageType.CALL, self._seqid)
    args = ResetSnapPriveteKey_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ResetSnapPriveteKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ResetSnapPriveteKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ResetSnapPriveteKey failed: unknown result")

  def SetCompatible(self, compatible):
    """
    Parameters:
     - compatible
    """
    self.send_SetCompatible(compatible)
    self.recv_SetCompatible()

  def send_SetCompatible(self, compatible):
    self._oprot.writeMessageBegin('SetCompatible', TMessageType.CALL, self._seqid)
    args = SetCompatible_args()
    args.compatible = compatible
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetCompatible(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetCompatible_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetCompatible(self):
    self.send_GetCompatible()
    return self.recv_GetCompatible()

  def send_GetCompatible(self):
    self._oprot.writeMessageBegin('GetCompatible', TMessageType.CALL, self._seqid)
    args = GetCompatible_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetCompatible(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetCompatible_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetCompatible failed: unknown result")

  def SetImgTransProperties(self, snap_type, img_trans_prop):
    """
    set the img transfer properties *

    Parameters:
     - snap_type
     - img_trans_prop
    """
    self.send_SetImgTransProperties(snap_type, img_trans_prop)
    self.recv_SetImgTransProperties()

  def send_SetImgTransProperties(self, snap_type, img_trans_prop):
    self._oprot.writeMessageBegin('SetImgTransProperties', TMessageType.CALL, self._seqid)
    args = SetImgTransProperties_args()
    args.snap_type = snap_type
    args.img_trans_prop = img_trans_prop
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetImgTransProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetImgTransProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetImgTransProperties(self, snap_type):
    """
    get the img transfer properties *

    Parameters:
     - snap_type
    """
    self.send_GetImgTransProperties(snap_type)
    return self.recv_GetImgTransProperties()

  def send_GetImgTransProperties(self, snap_type):
    self._oprot.writeMessageBegin('GetImgTransProperties', TMessageType.CALL, self._seqid)
    args = GetImgTransProperties_args()
    args.snap_type = snap_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetImgTransProperties(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetImgTransProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetImgTransProperties failed: unknown result")

  def SetImgTransList(self, snap_type):
    """
    配置图传类型列表　enable the img transfer task of the corresponding tasks *

    Parameters:
     - snap_type
    """
    self.send_SetImgTransList(snap_type)
    self.recv_SetImgTransList()

  def send_SetImgTransList(self, snap_type):
    self._oprot.writeMessageBegin('SetImgTransList', TMessageType.CALL, self._seqid)
    args = SetImgTransList_args()
    args.snap_type = snap_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetImgTransList(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SetImgTransList_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def GetImgTransList(self):
    """
    get the list img transfer tasks *
    """
    self.send_GetImgTransList()
    return self.recv_GetImgTransList()

  def send_GetImgTransList(self):
    self._oprot.writeMessageBegin('GetImgTransList', TMessageType.CALL, self._seqid)
    args = GetImgTransList_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetImgTransList(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetImgTransList_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.excpt is not None:
      raise result.excpt
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetImgTransList failed: unknown result")

  def SaveParam(self):
    """
    save to local file *
    """
    self.send_SaveParam()
    self.recv_SaveParam()

  def send_SaveParam(self):
    self._oprot.writeMessageBegin('SaveParam', TMessageType.CALL, self._seqid)
    args = SaveParam_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SaveParam(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = SaveParam_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def LoadParam(self):
    """
    read from local file *
    """
    self.send_LoadParam()
    self.recv_LoadParam()

  def send_LoadParam(self):
    self._oprot.writeMessageBegin('LoadParam', TMessageType.CALL, self._seqid)
    args = LoadParam_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_LoadParam(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = LoadParam_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def StartLibraF(self):
    self.send_StartLibraF()
    self.recv_StartLibraF()

  def send_StartLibraF(self):
    self._oprot.writeMessageBegin('StartLibraF', TMessageType.CALL, self._seqid)
    args = StartLibraF_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_StartLibraF(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = StartLibraF_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return

  def StopLibraF(self):
    self.send_StopLibraF()
    self.recv_StopLibraF()

  def send_StopLibraF(self):
    self._oprot.writeMessageBegin('StopLibraF', TMessageType.CALL, self._seqid)
    args = StopLibraF_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_StopLibraF(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = StopLibraF_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.excpt is not None:
      raise result.excpt
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["Stop"] = Processor.process_Stop
    self._processMap["GetWorkMode"] = Processor.process_GetWorkMode
    self._processMap["SetWorkMode"] = Processor.process_SetWorkMode
    self._processMap["SwitchToPassiveModeWithTimer"] = Processor.process_SwitchToPassiveModeWithTimer
    self._processMap["IsBlocking"] = Processor.process_IsBlocking
    self._processMap["SetIRCut"] = Processor.process_SetIRCut
    self._processMap["GetIRCut"] = Processor.process_GetIRCut
    self._processMap["SetDayNight"] = Processor.process_SetDayNight
    self._processMap["GetDayNight"] = Processor.process_GetDayNight
    self._processMap["GetRawImg"] = Processor.process_GetRawImg
    self._processMap["GetStreamImg"] = Processor.process_GetStreamImg
    self._processMap["GetFullSzRawImg"] = Processor.process_GetFullSzRawImg
    self._processMap["GetUndistortWideImg"] = Processor.process_GetUndistortWideImg
    self._processMap["GetSensorProperties"] = Processor.process_GetSensorProperties
    self._processMap["SetSensorProperties"] = Processor.process_SetSensorProperties
    self._processMap["SetIrisOffset"] = Processor.process_SetIrisOffset
    self._processMap["GetIrisOffset"] = Processor.process_GetIrisOffset
    self._processMap["GetMotorProperties"] = Processor.process_GetMotorProperties
    self._processMap["SetMotorProperties"] = Processor.process_SetMotorProperties
    self._processMap["SetLookAtPointOnStream"] = Processor.process_SetLookAtPointOnStream
    self._processMap["MoveLookAtPointOnStream"] = Processor.process_MoveLookAtPointOnStream
    self._processMap["SetLookAtPoint"] = Processor.process_SetLookAtPoint
    self._processMap["RotateMotorSmallStep"] = Processor.process_RotateMotorSmallStep
    self._processMap["RotateMotorWithGivenStepLevel"] = Processor.process_RotateMotorWithGivenStepLevel
    self._processMap["ResetMotor"] = Processor.process_ResetMotor
    self._processMap["SetLayoutProperties"] = Processor.process_SetLayoutProperties
    self._processMap["GetLayoutProperties"] = Processor.process_GetLayoutProperties
    self._processMap["SetSmartStreamType"] = Processor.process_SetSmartStreamType
    self._processMap["GetSmartStreamType"] = Processor.process_GetSmartStreamType
    self._processMap["SetStreamProperties"] = Processor.process_SetStreamProperties
    self._processMap["GetStreamProperties"] = Processor.process_GetStreamProperties
    self._processMap["SetTwoStreamProperties"] = Processor.process_SetTwoStreamProperties
    self._processMap["GetTwoStreamProperties"] = Processor.process_GetTwoStreamProperties
    self._processMap["SetDetectionProperties"] = Processor.process_SetDetectionProperties
    self._processMap["GetDetectionProperties"] = Processor.process_GetDetectionProperties
    self._processMap["SetImageMasks"] = Processor.process_SetImageMasks
    self._processMap["GetImageMasks"] = Processor.process_GetImageMasks
    self._processMap["SetMaskOn"] = Processor.process_SetMaskOn
    self._processMap["GetMaskOn"] = Processor.process_GetMaskOn
    self._processMap["Calibrate"] = Processor.process_Calibrate
    self._processMap["StopCali"] = Processor.process_StopCali
    self._processMap["CaliBusy"] = Processor.process_CaliBusy
    self._processMap["CaliState"] = Processor.process_CaliState
    self._processMap["GetAlignROI"] = Processor.process_GetAlignROI
    self._processMap["LearnBGM"] = Processor.process_LearnBGM
    self._processMap["LearnBGMState"] = Processor.process_LearnBGMState
    self._processMap["GetBGMSensitivity"] = Processor.process_GetBGMSensitivity
    self._processMap["SetBGMSensitivity"] = Processor.process_SetBGMSensitivity
    self._processMap["SetFontProperties"] = Processor.process_SetFontProperties
    self._processMap["GetFontProperties"] = Processor.process_GetFontProperties
    self._processMap["SetOSDOthers"] = Processor.process_SetOSDOthers
    self._processMap["GetOSDOthers"] = Processor.process_GetOSDOthers
    self._processMap["SetTextAlign"] = Processor.process_SetTextAlign
    self._processMap["GetTextAlign"] = Processor.process_GetTextAlign
    self._processMap["SetDrawBBS"] = Processor.process_SetDrawBBS
    self._processMap["GetDrawBBS"] = Processor.process_GetDrawBBS
    self._processMap["SetDrawView"] = Processor.process_SetDrawView
    self._processMap["GetDrawView"] = Processor.process_GetDrawView
    self._processMap["SetDrawDetGrid"] = Processor.process_SetDrawDetGrid
    self._processMap["GetDrawDetGrid"] = Processor.process_GetDrawDetGrid
    self._processMap["SetDetTasks"] = Processor.process_SetDetTasks
    self._processMap["GetDetTasks"] = Processor.process_GetDetTasks
    self._processMap["SetSnapProps"] = Processor.process_SetSnapProps
    self._processMap["GetSnapProps"] = Processor.process_GetSnapProps
    self._processMap["GetSnapConnectionInfo"] = Processor.process_GetSnapConnectionInfo
    self._processMap["GetSnapPublicKey"] = Processor.process_GetSnapPublicKey
    self._processMap["ResetSnapPriveteKey"] = Processor.process_ResetSnapPriveteKey
    self._processMap["SetCompatible"] = Processor.process_SetCompatible
    self._processMap["GetCompatible"] = Processor.process_GetCompatible
    self._processMap["SetImgTransProperties"] = Processor.process_SetImgTransProperties
    self._processMap["GetImgTransProperties"] = Processor.process_GetImgTransProperties
    self._processMap["SetImgTransList"] = Processor.process_SetImgTransList
    self._processMap["GetImgTransList"] = Processor.process_GetImgTransList
    self._processMap["SaveParam"] = Processor.process_SaveParam
    self._processMap["LoadParam"] = Processor.process_LoadParam
    self._processMap["StartLibraF"] = Processor.process_StartLibraF
    self._processMap["StopLibraF"] = Processor.process_StopLibraF

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_Stop(self, seqid, iprot, oprot):
    args = Stop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Stop_result()
    try:
      self._handler.Stop()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("Stop", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetWorkMode(self, seqid, iprot, oprot):
    args = GetWorkMode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetWorkMode_result()
    try:
      result.success = self._handler.GetWorkMode()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetWorkMode", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetWorkMode(self, seqid, iprot, oprot):
    args = SetWorkMode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetWorkMode_result()
    try:
      self._handler.SetWorkMode(args.work_mode)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetWorkMode", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SwitchToPassiveModeWithTimer(self, seqid, iprot, oprot):
    args = SwitchToPassiveModeWithTimer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SwitchToPassiveModeWithTimer_result()
    try:
      self._handler.SwitchToPassiveModeWithTimer()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SwitchToPassiveModeWithTimer", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsBlocking(self, seqid, iprot, oprot):
    args = IsBlocking_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsBlocking_result()
    try:
      result.success = self._handler.IsBlocking()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("IsBlocking", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetIRCut(self, seqid, iprot, oprot):
    args = SetIRCut_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetIRCut_result()
    try:
      self._handler.SetIRCut(args.is_ir_on)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetIRCut", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetIRCut(self, seqid, iprot, oprot):
    args = GetIRCut_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetIRCut_result()
    try:
      result.success = self._handler.GetIRCut()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetIRCut", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetDayNight(self, seqid, iprot, oprot):
    args = SetDayNight_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetDayNight_result()
    try:
      self._handler.SetDayNight(args.interval)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetDayNight", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetDayNight(self, seqid, iprot, oprot):
    args = GetDayNight_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetDayNight_result()
    try:
      result.success = self._handler.GetDayNight()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetDayNight", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetRawImg(self, seqid, iprot, oprot):
    args = GetRawImg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetRawImg_result()
    try:
      result.success = self._handler.GetRawImg(args.sensor_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetRawImg", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetStreamImg(self, seqid, iprot, oprot):
    args = GetStreamImg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetStreamImg_result()
    try:
      result.success = self._handler.GetStreamImg()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetStreamImg", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetFullSzRawImg(self, seqid, iprot, oprot):
    args = GetFullSzRawImg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetFullSzRawImg_result()
    try:
      result.success = self._handler.GetFullSzRawImg(args.sensor_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetFullSzRawImg", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetUndistortWideImg(self, seqid, iprot, oprot):
    args = GetUndistortWideImg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetUndistortWideImg_result()
    try:
      result.success = self._handler.GetUndistortWideImg(args.undistort_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetUndistortWideImg", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSensorProperties(self, seqid, iprot, oprot):
    args = GetSensorProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSensorProperties_result()
    try:
      result.success = self._handler.GetSensorProperties(args.sensor_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetSensorProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSensorProperties(self, seqid, iprot, oprot):
    args = SetSensorProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSensorProperties_result()
    try:
      self._handler.SetSensorProperties(args.sensor_type, args.sensor_prop)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetSensorProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetIrisOffset(self, seqid, iprot, oprot):
    args = SetIrisOffset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetIrisOffset_result()
    try:
      self._handler.SetIrisOffset(args.sensor_type, args.offset)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetIrisOffset", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetIrisOffset(self, seqid, iprot, oprot):
    args = GetIrisOffset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetIrisOffset_result()
    try:
      result.success = self._handler.GetIrisOffset(args.sensor_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetIrisOffset", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetMotorProperties(self, seqid, iprot, oprot):
    args = GetMotorProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetMotorProperties_result()
    try:
      result.success = self._handler.GetMotorProperties()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetMotorProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetMotorProperties(self, seqid, iprot, oprot):
    args = SetMotorProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetMotorProperties_result()
    try:
      self._handler.SetMotorProperties(args.motor_prop)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetMotorProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetLookAtPointOnStream(self, seqid, iprot, oprot):
    args = SetLookAtPointOnStream_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetLookAtPointOnStream_result()
    try:
      self._handler.SetLookAtPointOnStream(args.point)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetLookAtPointOnStream", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_MoveLookAtPointOnStream(self, seqid, iprot, oprot):
    args = MoveLookAtPointOnStream_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = MoveLookAtPointOnStream_result()
    try:
      self._handler.MoveLookAtPointOnStream(args.point)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("MoveLookAtPointOnStream", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetLookAtPoint(self, seqid, iprot, oprot):
    args = SetLookAtPoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetLookAtPoint_result()
    try:
      self._handler.SetLookAtPoint(args.point)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetLookAtPoint", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RotateMotorSmallStep(self, seqid, iprot, oprot):
    args = RotateMotorSmallStep_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RotateMotorSmallStep_result()
    try:
      self._handler.RotateMotorSmallStep(args.rot_type, args.nsteps)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("RotateMotorSmallStep", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RotateMotorWithGivenStepLevel(self, seqid, iprot, oprot):
    args = RotateMotorWithGivenStepLevel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RotateMotorWithGivenStepLevel_result()
    try:
      self._handler.RotateMotorWithGivenStepLevel(args.rot_type, args.level)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("RotateMotorWithGivenStepLevel", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ResetMotor(self, seqid, iprot, oprot):
    args = ResetMotor_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ResetMotor_result()
    try:
      self._handler.ResetMotor()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("ResetMotor", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetLayoutProperties(self, seqid, iprot, oprot):
    args = SetLayoutProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetLayoutProperties_result()
    try:
      self._handler.SetLayoutProperties(args.layout_prop)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetLayoutProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetLayoutProperties(self, seqid, iprot, oprot):
    args = GetLayoutProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetLayoutProperties_result()
    try:
      result.success = self._handler.GetLayoutProperties()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetLayoutProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSmartStreamType(self, seqid, iprot, oprot):
    args = SetSmartStreamType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSmartStreamType_result()
    try:
      self._handler.SetSmartStreamType(args.smart_stream_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetSmartStreamType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSmartStreamType(self, seqid, iprot, oprot):
    args = GetSmartStreamType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSmartStreamType_result()
    try:
      result.success = self._handler.GetSmartStreamType()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetSmartStreamType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetStreamProperties(self, seqid, iprot, oprot):
    args = SetStreamProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetStreamProperties_result()
    try:
      self._handler.SetStreamProperties(args.stream_type, args.stream_prop)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetStreamProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetStreamProperties(self, seqid, iprot, oprot):
    args = GetStreamProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetStreamProperties_result()
    try:
      result.success = self._handler.GetStreamProperties(args.stream_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetStreamProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetTwoStreamProperties(self, seqid, iprot, oprot):
    args = SetTwoStreamProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetTwoStreamProperties_result()
    try:
      self._handler.SetTwoStreamProperties(args.stream_prop)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetTwoStreamProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetTwoStreamProperties(self, seqid, iprot, oprot):
    args = GetTwoStreamProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetTwoStreamProperties_result()
    try:
      result.success = self._handler.GetTwoStreamProperties()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetTwoStreamProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetDetectionProperties(self, seqid, iprot, oprot):
    args = SetDetectionProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetDetectionProperties_result()
    try:
      self._handler.SetDetectionProperties(args.det_roi)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetDetectionProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetDetectionProperties(self, seqid, iprot, oprot):
    args = GetDetectionProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetDetectionProperties_result()
    try:
      result.success = self._handler.GetDetectionProperties()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetDetectionProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetImageMasks(self, seqid, iprot, oprot):
    args = SetImageMasks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetImageMasks_result()
    try:
      self._handler.SetImageMasks(args.img_masks)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetImageMasks", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetImageMasks(self, seqid, iprot, oprot):
    args = GetImageMasks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetImageMasks_result()
    try:
      result.success = self._handler.GetImageMasks()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetImageMasks", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetMaskOn(self, seqid, iprot, oprot):
    args = SetMaskOn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetMaskOn_result()
    try:
      self._handler.SetMaskOn(args.is_mask_on)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetMaskOn", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetMaskOn(self, seqid, iprot, oprot):
    args = GetMaskOn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetMaskOn_result()
    try:
      result.success = self._handler.GetMaskOn()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetMaskOn", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_Calibrate(self, seqid, iprot, oprot):
    args = Calibrate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Calibrate_result()
    try:
      self._handler.Calibrate(args.is_auto)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("Calibrate", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_StopCali(self, seqid, iprot, oprot):
    args = StopCali_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = StopCali_result()
    try:
      self._handler.StopCali()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("StopCali", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CaliBusy(self, seqid, iprot, oprot):
    args = CaliBusy_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CaliBusy_result()
    try:
      result.success = self._handler.CaliBusy()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("CaliBusy", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CaliState(self, seqid, iprot, oprot):
    args = CaliState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CaliState_result()
    try:
      result.success = self._handler.CaliState()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("CaliState", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAlignROI(self, seqid, iprot, oprot):
    args = GetAlignROI_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAlignROI_result()
    try:
      result.success = self._handler.GetAlignROI()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetAlignROI", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LearnBGM(self, seqid, iprot, oprot):
    args = LearnBGM_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LearnBGM_result()
    try:
      self._handler.LearnBGM()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LearnBGM", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LearnBGMState(self, seqid, iprot, oprot):
    args = LearnBGMState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LearnBGMState_result()
    try:
      result.success = self._handler.LearnBGMState()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LearnBGMState", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetBGMSensitivity(self, seqid, iprot, oprot):
    args = GetBGMSensitivity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetBGMSensitivity_result()
    try:
      result.success = self._handler.GetBGMSensitivity()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetBGMSensitivity", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetBGMSensitivity(self, seqid, iprot, oprot):
    args = SetBGMSensitivity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetBGMSensitivity_result()
    try:
      self._handler.SetBGMSensitivity(args.sen)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetBGMSensitivity", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetFontProperties(self, seqid, iprot, oprot):
    args = SetFontProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetFontProperties_result()
    try:
      self._handler.SetFontProperties(args.text_type, args.font_prop)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetFontProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetFontProperties(self, seqid, iprot, oprot):
    args = GetFontProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetFontProperties_result()
    try:
      result.success = self._handler.GetFontProperties(args.text_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetFontProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetOSDOthers(self, seqid, iprot, oprot):
    args = SetOSDOthers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetOSDOthers_result()
    try:
      self._handler.SetOSDOthers(args.osd_other)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetOSDOthers", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetOSDOthers(self, seqid, iprot, oprot):
    args = GetOSDOthers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetOSDOthers_result()
    try:
      result.success = self._handler.GetOSDOthers()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetOSDOthers", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetTextAlign(self, seqid, iprot, oprot):
    args = SetTextAlign_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetTextAlign_result()
    try:
      self._handler.SetTextAlign(args.text_type, args.align_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetTextAlign", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetTextAlign(self, seqid, iprot, oprot):
    args = GetTextAlign_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetTextAlign_result()
    try:
      result.success = self._handler.GetTextAlign(args.text_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetTextAlign", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetDrawBBS(self, seqid, iprot, oprot):
    args = SetDrawBBS_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetDrawBBS_result()
    try:
      self._handler.SetDrawBBS(args.is_draw_bbs_)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetDrawBBS", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetDrawBBS(self, seqid, iprot, oprot):
    args = GetDrawBBS_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetDrawBBS_result()
    try:
      result.success = self._handler.GetDrawBBS()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetDrawBBS", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetDrawView(self, seqid, iprot, oprot):
    args = SetDrawView_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetDrawView_result()
    try:
      self._handler.SetDrawView(args.is_draw_view_)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetDrawView", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetDrawView(self, seqid, iprot, oprot):
    args = GetDrawView_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetDrawView_result()
    try:
      result.success = self._handler.GetDrawView()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetDrawView", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetDrawDetGrid(self, seqid, iprot, oprot):
    args = SetDrawDetGrid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetDrawDetGrid_result()
    try:
      self._handler.SetDrawDetGrid(args.is_draw_)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetDrawDetGrid", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetDrawDetGrid(self, seqid, iprot, oprot):
    args = GetDrawDetGrid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetDrawDetGrid_result()
    try:
      result.success = self._handler.GetDrawDetGrid()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetDrawDetGrid", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetDetTasks(self, seqid, iprot, oprot):
    args = SetDetTasks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetDetTasks_result()
    try:
      self._handler.SetDetTasks(args.snap_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetDetTasks", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetDetTasks(self, seqid, iprot, oprot):
    args = GetDetTasks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetDetTasks_result()
    try:
      result.success = self._handler.GetDetTasks()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetDetTasks", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSnapProps(self, seqid, iprot, oprot):
    args = SetSnapProps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSnapProps_result()
    try:
      self._handler.SetSnapProps(args.snap_props)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetSnapProps", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSnapProps(self, seqid, iprot, oprot):
    args = GetSnapProps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSnapProps_result()
    try:
      result.success = self._handler.GetSnapProps()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetSnapProps", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSnapConnectionInfo(self, seqid, iprot, oprot):
    args = GetSnapConnectionInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSnapConnectionInfo_result()
    try:
      result.success = self._handler.GetSnapConnectionInfo()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetSnapConnectionInfo", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSnapPublicKey(self, seqid, iprot, oprot):
    args = GetSnapPublicKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSnapPublicKey_result()
    try:
      result.success = self._handler.GetSnapPublicKey()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetSnapPublicKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ResetSnapPriveteKey(self, seqid, iprot, oprot):
    args = ResetSnapPriveteKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ResetSnapPriveteKey_result()
    try:
      result.success = self._handler.ResetSnapPriveteKey()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("ResetSnapPriveteKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetCompatible(self, seqid, iprot, oprot):
    args = SetCompatible_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetCompatible_result()
    try:
      self._handler.SetCompatible(args.compatible)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetCompatible", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCompatible(self, seqid, iprot, oprot):
    args = GetCompatible_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCompatible_result()
    try:
      result.success = self._handler.GetCompatible()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetCompatible", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetImgTransProperties(self, seqid, iprot, oprot):
    args = SetImgTransProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetImgTransProperties_result()
    try:
      self._handler.SetImgTransProperties(args.snap_type, args.img_trans_prop)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetImgTransProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetImgTransProperties(self, seqid, iprot, oprot):
    args = GetImgTransProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetImgTransProperties_result()
    try:
      result.success = self._handler.GetImgTransProperties(args.snap_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetImgTransProperties", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetImgTransList(self, seqid, iprot, oprot):
    args = SetImgTransList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetImgTransList_result()
    try:
      self._handler.SetImgTransList(args.snap_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SetImgTransList", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetImgTransList(self, seqid, iprot, oprot):
    args = GetImgTransList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetImgTransList_result()
    try:
      result.success = self._handler.GetImgTransList()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("GetImgTransList", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SaveParam(self, seqid, iprot, oprot):
    args = SaveParam_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SaveParam_result()
    try:
      self._handler.SaveParam()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("SaveParam", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LoadParam(self, seqid, iprot, oprot):
    args = LoadParam_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LoadParam_result()
    try:
      self._handler.LoadParam()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("LoadParam", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_StartLibraF(self, seqid, iprot, oprot):
    args = StartLibraF_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = StartLibraF_result()
    try:
      self._handler.StartLibraF()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("StartLibraF", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_StopLibraF(self, seqid, iprot, oprot):
    args = StopLibraF_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = StopLibraF_result()
    try:
      self._handler.StopLibraF()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except RpcLibraFException as excpt:
      msg_type = TMessageType.REPLY
      result.excpt = excpt
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("StopLibraF", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class Stop_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Stop_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Stop_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Stop_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetWorkMode_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetWorkMode_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetWorkMode_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetWorkMode_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetWorkMode_args:
  """
  Attributes:
   - work_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'work_mode', None, None, ), # 1
  )

  def __init__(self, work_mode=None,):
    self.work_mode = work_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.work_mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetWorkMode_args')
    if self.work_mode is not None:
      oprot.writeFieldBegin('work_mode', TType.I32, 1)
      oprot.writeI32(self.work_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.work_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetWorkMode_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetWorkMode_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchToPassiveModeWithTimer_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchToPassiveModeWithTimer_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SwitchToPassiveModeWithTimer_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SwitchToPassiveModeWithTimer_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsBlocking_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsBlocking_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsBlocking_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsBlocking_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetIRCut_args:
  """
  Attributes:
   - is_ir_on
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_ir_on', None, None, ), # 1
  )

  def __init__(self, is_ir_on=None,):
    self.is_ir_on = is_ir_on

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_ir_on = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetIRCut_args')
    if self.is_ir_on is not None:
      oprot.writeFieldBegin('is_ir_on', TType.BOOL, 1)
      oprot.writeBool(self.is_ir_on)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_ir_on)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetIRCut_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetIRCut_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetIRCut_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetIRCut_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetIRCut_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetIRCut_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDayNight_args:
  """
  Attributes:
   - interval
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'interval', (RpcDayNightTime, RpcDayNightTime.thrift_spec), None, ), # 1
  )

  def __init__(self, interval=None,):
    self.interval = interval

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.interval = RpcDayNightTime()
          self.interval.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDayNight_args')
    if self.interval is not None:
      oprot.writeFieldBegin('interval', TType.STRUCT, 1)
      self.interval.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.interval)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDayNight_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDayNight_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDayNight_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDayNight_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDayNight_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcDayNightTime, RpcDayNightTime.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcDayNightTime()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDayNight_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRawImg_args:
  """
  Attributes:
   - sensor_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sensor_type', None, None, ), # 1
  )

  def __init__(self, sensor_type=None,):
    self.sensor_type = sensor_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sensor_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRawImg_args')
    if self.sensor_type is not None:
      oprot.writeFieldBegin('sensor_type', TType.I32, 1)
      oprot.writeI32(self.sensor_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sensor_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRawImg_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcMat, RpcMat.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcMat()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRawImg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetStreamImg_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetStreamImg_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetStreamImg_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcMat, RpcMat.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcMat()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetStreamImg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFullSzRawImg_args:
  """
  Attributes:
   - sensor_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sensor_type', None, None, ), # 1
  )

  def __init__(self, sensor_type=None,):
    self.sensor_type = sensor_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sensor_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFullSzRawImg_args')
    if self.sensor_type is not None:
      oprot.writeFieldBegin('sensor_type', TType.I32, 1)
      oprot.writeI32(self.sensor_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sensor_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFullSzRawImg_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcMat, RpcMat.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcMat()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFullSzRawImg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetUndistortWideImg_args:
  """
  Attributes:
   - undistort_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'undistort_type', None, None, ), # 1
  )

  def __init__(self, undistort_type=None,):
    self.undistort_type = undistort_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.undistort_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetUndistortWideImg_args')
    if self.undistort_type is not None:
      oprot.writeFieldBegin('undistort_type', TType.I32, 1)
      oprot.writeI32(self.undistort_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.undistort_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetUndistortWideImg_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcMat, RpcMat.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcMat()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetUndistortWideImg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSensorProperties_args:
  """
  Attributes:
   - sensor_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sensor_type', None, None, ), # 1
  )

  def __init__(self, sensor_type=None,):
    self.sensor_type = sensor_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sensor_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSensorProperties_args')
    if self.sensor_type is not None:
      oprot.writeFieldBegin('sensor_type', TType.I32, 1)
      oprot.writeI32(self.sensor_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sensor_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSensorProperties_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcSensorProp, RpcSensorProp.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcSensorProp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSensorProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSensorProperties_args:
  """
  Attributes:
   - sensor_type
   - sensor_prop
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sensor_type', None, None, ), # 1
    (2, TType.STRUCT, 'sensor_prop', (RpcSensorProp, RpcSensorProp.thrift_spec), None, ), # 2
  )

  def __init__(self, sensor_type=None, sensor_prop=None,):
    self.sensor_type = sensor_type
    self.sensor_prop = sensor_prop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sensor_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sensor_prop = RpcSensorProp()
          self.sensor_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSensorProperties_args')
    if self.sensor_type is not None:
      oprot.writeFieldBegin('sensor_type', TType.I32, 1)
      oprot.writeI32(self.sensor_type)
      oprot.writeFieldEnd()
    if self.sensor_prop is not None:
      oprot.writeFieldBegin('sensor_prop', TType.STRUCT, 2)
      self.sensor_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sensor_type)
    value = (value * 31) ^ hash(self.sensor_prop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSensorProperties_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSensorProperties_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetIrisOffset_args:
  """
  Attributes:
   - sensor_type
   - offset
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sensor_type', None, None, ), # 1
    (2, TType.I32, 'offset', None, None, ), # 2
  )

  def __init__(self, sensor_type=None, offset=None,):
    self.sensor_type = sensor_type
    self.offset = offset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sensor_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetIrisOffset_args')
    if self.sensor_type is not None:
      oprot.writeFieldBegin('sensor_type', TType.I32, 1)
      oprot.writeI32(self.sensor_type)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 2)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sensor_type)
    value = (value * 31) ^ hash(self.offset)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetIrisOffset_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetIrisOffset_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetIrisOffset_args:
  """
  Attributes:
   - sensor_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sensor_type', None, None, ), # 1
  )

  def __init__(self, sensor_type=None,):
    self.sensor_type = sensor_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sensor_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetIrisOffset_args')
    if self.sensor_type is not None:
      oprot.writeFieldBegin('sensor_type', TType.I32, 1)
      oprot.writeI32(self.sensor_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sensor_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetIrisOffset_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetIrisOffset_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMotorProperties_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMotorProperties_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMotorProperties_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcMotorProp, RpcMotorProp.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcMotorProp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMotorProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetMotorProperties_args:
  """
  Attributes:
   - motor_prop
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'motor_prop', (RpcMotorProp, RpcMotorProp.thrift_spec), None, ), # 1
  )

  def __init__(self, motor_prop=None,):
    self.motor_prop = motor_prop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.motor_prop = RpcMotorProp()
          self.motor_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetMotorProperties_args')
    if self.motor_prop is not None:
      oprot.writeFieldBegin('motor_prop', TType.STRUCT, 1)
      self.motor_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.motor_prop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetMotorProperties_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetMotorProperties_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetLookAtPointOnStream_args:
  """
  Attributes:
   - point
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'point', (RpcPoint, RpcPoint.thrift_spec), None, ), # 1
  )

  def __init__(self, point=None,):
    self.point = point

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.point = RpcPoint()
          self.point.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetLookAtPointOnStream_args')
    if self.point is not None:
      oprot.writeFieldBegin('point', TType.STRUCT, 1)
      self.point.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.point)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetLookAtPointOnStream_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetLookAtPointOnStream_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MoveLookAtPointOnStream_args:
  """
  Attributes:
   - point
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'point', (RpcPoint, RpcPoint.thrift_spec), None, ), # 1
  )

  def __init__(self, point=None,):
    self.point = point

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.point = RpcPoint()
          self.point.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MoveLookAtPointOnStream_args')
    if self.point is not None:
      oprot.writeFieldBegin('point', TType.STRUCT, 1)
      self.point.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.point)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MoveLookAtPointOnStream_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MoveLookAtPointOnStream_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetLookAtPoint_args:
  """
  Attributes:
   - point
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'point', (RpcPoint, RpcPoint.thrift_spec), None, ), # 1
  )

  def __init__(self, point=None,):
    self.point = point

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.point = RpcPoint()
          self.point.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetLookAtPoint_args')
    if self.point is not None:
      oprot.writeFieldBegin('point', TType.STRUCT, 1)
      self.point.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.point)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetLookAtPoint_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetLookAtPoint_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RotateMotorSmallStep_args:
  """
  Attributes:
   - rot_type
   - nsteps
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'rot_type', None, None, ), # 1
    (2, TType.I32, 'nsteps', None, None, ), # 2
  )

  def __init__(self, rot_type=None, nsteps=None,):
    self.rot_type = rot_type
    self.nsteps = nsteps

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.rot_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.nsteps = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RotateMotorSmallStep_args')
    if self.rot_type is not None:
      oprot.writeFieldBegin('rot_type', TType.I32, 1)
      oprot.writeI32(self.rot_type)
      oprot.writeFieldEnd()
    if self.nsteps is not None:
      oprot.writeFieldBegin('nsteps', TType.I32, 2)
      oprot.writeI32(self.nsteps)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rot_type)
    value = (value * 31) ^ hash(self.nsteps)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RotateMotorSmallStep_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RotateMotorSmallStep_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RotateMotorWithGivenStepLevel_args:
  """
  Attributes:
   - rot_type
   - level
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'rot_type', None, None, ), # 1
    (2, TType.I32, 'level', None, None, ), # 2
  )

  def __init__(self, rot_type=None, level=None,):
    self.rot_type = rot_type
    self.level = level

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.rot_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.level = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RotateMotorWithGivenStepLevel_args')
    if self.rot_type is not None:
      oprot.writeFieldBegin('rot_type', TType.I32, 1)
      oprot.writeI32(self.rot_type)
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 2)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rot_type)
    value = (value * 31) ^ hash(self.level)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RotateMotorWithGivenStepLevel_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RotateMotorWithGivenStepLevel_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResetMotor_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResetMotor_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResetMotor_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResetMotor_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetLayoutProperties_args:
  """
  Attributes:
   - layout_prop
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'layout_prop', (RpcLayoutProp, RpcLayoutProp.thrift_spec), None, ), # 1
  )

  def __init__(self, layout_prop=None,):
    self.layout_prop = layout_prop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.layout_prop = RpcLayoutProp()
          self.layout_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetLayoutProperties_args')
    if self.layout_prop is not None:
      oprot.writeFieldBegin('layout_prop', TType.STRUCT, 1)
      self.layout_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.layout_prop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetLayoutProperties_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetLayoutProperties_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLayoutProperties_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLayoutProperties_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLayoutProperties_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcLayoutProp, RpcLayoutProp.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcLayoutProp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLayoutProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSmartStreamType_args:
  """
  Attributes:
   - smart_stream_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'smart_stream_type', None, None, ), # 1
  )

  def __init__(self, smart_stream_type=None,):
    self.smart_stream_type = smart_stream_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.smart_stream_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSmartStreamType_args')
    if self.smart_stream_type is not None:
      oprot.writeFieldBegin('smart_stream_type', TType.I32, 1)
      oprot.writeI32(self.smart_stream_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.smart_stream_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSmartStreamType_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSmartStreamType_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSmartStreamType_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSmartStreamType_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSmartStreamType_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSmartStreamType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetStreamProperties_args:
  """
  Attributes:
   - stream_type
   - stream_prop
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'stream_type', None, None, ), # 1
    (2, TType.STRUCT, 'stream_prop', (RpcStreamProperties, RpcStreamProperties.thrift_spec), None, ), # 2
  )

  def __init__(self, stream_type=None, stream_prop=None,):
    self.stream_type = stream_type
    self.stream_prop = stream_prop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.stream_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.stream_prop = RpcStreamProperties()
          self.stream_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetStreamProperties_args')
    if self.stream_type is not None:
      oprot.writeFieldBegin('stream_type', TType.I32, 1)
      oprot.writeI32(self.stream_type)
      oprot.writeFieldEnd()
    if self.stream_prop is not None:
      oprot.writeFieldBegin('stream_prop', TType.STRUCT, 2)
      self.stream_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stream_type)
    value = (value * 31) ^ hash(self.stream_prop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetStreamProperties_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetStreamProperties_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetStreamProperties_args:
  """
  Attributes:
   - stream_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'stream_type', None, None, ), # 1
  )

  def __init__(self, stream_type=None,):
    self.stream_type = stream_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.stream_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetStreamProperties_args')
    if self.stream_type is not None:
      oprot.writeFieldBegin('stream_type', TType.I32, 1)
      oprot.writeI32(self.stream_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stream_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetStreamProperties_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcStreamProperties, RpcStreamProperties.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcStreamProperties()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetStreamProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetTwoStreamProperties_args:
  """
  Attributes:
   - stream_prop
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'stream_prop', (RpcTwoStreamProperties, RpcTwoStreamProperties.thrift_spec), None, ), # 1
  )

  def __init__(self, stream_prop=None,):
    self.stream_prop = stream_prop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stream_prop = RpcTwoStreamProperties()
          self.stream_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetTwoStreamProperties_args')
    if self.stream_prop is not None:
      oprot.writeFieldBegin('stream_prop', TType.STRUCT, 1)
      self.stream_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stream_prop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetTwoStreamProperties_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetTwoStreamProperties_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTwoStreamProperties_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTwoStreamProperties_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTwoStreamProperties_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcTwoStreamProperties, RpcTwoStreamProperties.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcTwoStreamProperties()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTwoStreamProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDetectionProperties_args:
  """
  Attributes:
   - det_roi
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'det_roi', (RpcDetectProp, RpcDetectProp.thrift_spec), None, ), # 1
  )

  def __init__(self, det_roi=None,):
    self.det_roi = det_roi

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.det_roi = RpcDetectProp()
          self.det_roi.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDetectionProperties_args')
    if self.det_roi is not None:
      oprot.writeFieldBegin('det_roi', TType.STRUCT, 1)
      self.det_roi.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.det_roi)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDetectionProperties_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDetectionProperties_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDetectionProperties_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDetectionProperties_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDetectionProperties_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcDetectProp, RpcDetectProp.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcDetectProp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDetectionProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetImageMasks_args:
  """
  Attributes:
   - img_masks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'img_masks', (TType.LIST,(TType.STRUCT,(RpcPoint, RpcPoint.thrift_spec))), None, ), # 1
  )

  def __init__(self, img_masks=None,):
    self.img_masks = img_masks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.img_masks = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = []
            (_etype32, _size29) = iprot.readListBegin()
            for _i33 in xrange(_size29):
              _elem34 = RpcPoint()
              _elem34.read(iprot)
              _elem28.append(_elem34)
            iprot.readListEnd()
            self.img_masks.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetImageMasks_args')
    if self.img_masks is not None:
      oprot.writeFieldBegin('img_masks', TType.LIST, 1)
      oprot.writeListBegin(TType.LIST, len(self.img_masks))
      for iter35 in self.img_masks:
        oprot.writeListBegin(TType.STRUCT, len(iter35))
        for iter36 in iter35:
          iter36.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.img_masks)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetImageMasks_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetImageMasks_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetImageMasks_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetImageMasks_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetImageMasks_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST,(TType.STRUCT,(RpcPoint, RpcPoint.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype40, _size37) = iprot.readListBegin()
          for _i41 in xrange(_size37):
            _elem42 = []
            (_etype46, _size43) = iprot.readListBegin()
            for _i47 in xrange(_size43):
              _elem48 = RpcPoint()
              _elem48.read(iprot)
              _elem42.append(_elem48)
            iprot.readListEnd()
            self.success.append(_elem42)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetImageMasks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.LIST, len(self.success))
      for iter49 in self.success:
        oprot.writeListBegin(TType.STRUCT, len(iter49))
        for iter50 in iter49:
          iter50.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetMaskOn_args:
  """
  Attributes:
   - is_mask_on
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_mask_on', None, None, ), # 1
  )

  def __init__(self, is_mask_on=None,):
    self.is_mask_on = is_mask_on

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_mask_on = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetMaskOn_args')
    if self.is_mask_on is not None:
      oprot.writeFieldBegin('is_mask_on', TType.BOOL, 1)
      oprot.writeBool(self.is_mask_on)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_mask_on)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetMaskOn_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetMaskOn_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMaskOn_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMaskOn_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMaskOn_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMaskOn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Calibrate_args:
  """
  Attributes:
   - is_auto
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_auto', None, None, ), # 1
  )

  def __init__(self, is_auto=None,):
    self.is_auto = is_auto

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_auto = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Calibrate_args')
    if self.is_auto is not None:
      oprot.writeFieldBegin('is_auto', TType.BOOL, 1)
      oprot.writeBool(self.is_auto)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_auto)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Calibrate_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Calibrate_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StopCali_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StopCali_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StopCali_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StopCali_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CaliBusy_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CaliBusy_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CaliBusy_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CaliBusy_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CaliState_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CaliState_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CaliState_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CaliState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAlignROI_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAlignROI_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAlignROI_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcRect, RpcRect.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcRect()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAlignROI_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LearnBGM_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LearnBGM_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LearnBGM_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LearnBGM_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LearnBGMState_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LearnBGMState_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LearnBGMState_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LearnBGMState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetBGMSensitivity_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetBGMSensitivity_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetBGMSensitivity_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetBGMSensitivity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetBGMSensitivity_args:
  """
  Attributes:
   - sen
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'sen', None, None, ), # 1
  )

  def __init__(self, sen=None,):
    self.sen = sen

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.sen = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetBGMSensitivity_args')
    if self.sen is not None:
      oprot.writeFieldBegin('sen', TType.DOUBLE, 1)
      oprot.writeDouble(self.sen)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sen)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetBGMSensitivity_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetBGMSensitivity_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetFontProperties_args:
  """
  Attributes:
   - text_type
   - font_prop
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'text_type', None, None, ), # 1
    (2, TType.STRUCT, 'font_prop', (RpcFontProperties, RpcFontProperties.thrift_spec), None, ), # 2
  )

  def __init__(self, text_type=None, font_prop=None,):
    self.text_type = text_type
    self.font_prop = font_prop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.text_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.font_prop = RpcFontProperties()
          self.font_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetFontProperties_args')
    if self.text_type is not None:
      oprot.writeFieldBegin('text_type', TType.I32, 1)
      oprot.writeI32(self.text_type)
      oprot.writeFieldEnd()
    if self.font_prop is not None:
      oprot.writeFieldBegin('font_prop', TType.STRUCT, 2)
      self.font_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.text_type)
    value = (value * 31) ^ hash(self.font_prop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetFontProperties_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetFontProperties_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFontProperties_args:
  """
  Attributes:
   - text_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'text_type', None, None, ), # 1
  )

  def __init__(self, text_type=None,):
    self.text_type = text_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.text_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFontProperties_args')
    if self.text_type is not None:
      oprot.writeFieldBegin('text_type', TType.I32, 1)
      oprot.writeI32(self.text_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.text_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFontProperties_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcFontProperties, RpcFontProperties.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcFontProperties()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFontProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetOSDOthers_args:
  """
  Attributes:
   - osd_other
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'osd_other', (RpcOSDOther, RpcOSDOther.thrift_spec), None, ), # 1
  )

  def __init__(self, osd_other=None,):
    self.osd_other = osd_other

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.osd_other = RpcOSDOther()
          self.osd_other.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetOSDOthers_args')
    if self.osd_other is not None:
      oprot.writeFieldBegin('osd_other', TType.STRUCT, 1)
      self.osd_other.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.osd_other)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetOSDOthers_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetOSDOthers_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOSDOthers_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOSDOthers_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOSDOthers_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcOSDOther, RpcOSDOther.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcOSDOther()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOSDOthers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetTextAlign_args:
  """
  Attributes:
   - text_type
   - align_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'text_type', None, None, ), # 1
    (2, TType.I32, 'align_type', None, None, ), # 2
  )

  def __init__(self, text_type=None, align_type=None,):
    self.text_type = text_type
    self.align_type = align_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.text_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.align_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetTextAlign_args')
    if self.text_type is not None:
      oprot.writeFieldBegin('text_type', TType.I32, 1)
      oprot.writeI32(self.text_type)
      oprot.writeFieldEnd()
    if self.align_type is not None:
      oprot.writeFieldBegin('align_type', TType.I32, 2)
      oprot.writeI32(self.align_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.text_type)
    value = (value * 31) ^ hash(self.align_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetTextAlign_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetTextAlign_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTextAlign_args:
  """
  Attributes:
   - text_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'text_type', None, None, ), # 1
  )

  def __init__(self, text_type=None,):
    self.text_type = text_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.text_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTextAlign_args')
    if self.text_type is not None:
      oprot.writeFieldBegin('text_type', TType.I32, 1)
      oprot.writeI32(self.text_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.text_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTextAlign_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTextAlign_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDrawBBS_args:
  """
  Attributes:
   - is_draw_bbs_
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_draw_bbs_', None, None, ), # 1
  )

  def __init__(self, is_draw_bbs_=None,):
    self.is_draw_bbs_ = is_draw_bbs_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_draw_bbs_ = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDrawBBS_args')
    if self.is_draw_bbs_ is not None:
      oprot.writeFieldBegin('is_draw_bbs_', TType.BOOL, 1)
      oprot.writeBool(self.is_draw_bbs_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_draw_bbs_)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDrawBBS_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDrawBBS_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDrawBBS_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDrawBBS_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDrawBBS_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDrawBBS_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDrawView_args:
  """
  Attributes:
   - is_draw_view_
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_draw_view_', None, None, ), # 1
  )

  def __init__(self, is_draw_view_=None,):
    self.is_draw_view_ = is_draw_view_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_draw_view_ = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDrawView_args')
    if self.is_draw_view_ is not None:
      oprot.writeFieldBegin('is_draw_view_', TType.BOOL, 1)
      oprot.writeBool(self.is_draw_view_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_draw_view_)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDrawView_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDrawView_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDrawView_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDrawView_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDrawView_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDrawView_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDrawDetGrid_args:
  """
  Attributes:
   - is_draw_
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_draw_', None, None, ), # 1
  )

  def __init__(self, is_draw_=None,):
    self.is_draw_ = is_draw_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_draw_ = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDrawDetGrid_args')
    if self.is_draw_ is not None:
      oprot.writeFieldBegin('is_draw_', TType.BOOL, 1)
      oprot.writeBool(self.is_draw_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_draw_)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDrawDetGrid_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDrawDetGrid_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDrawDetGrid_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDrawDetGrid_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDrawDetGrid_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDrawDetGrid_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDetTasks_args:
  """
  Attributes:
   - snap_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'snap_type', (TType.I32,None), None, ), # 1
  )

  def __init__(self, snap_type=None,):
    self.snap_type = snap_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.snap_type = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = iprot.readI32()
            self.snap_type.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDetTasks_args')
    if self.snap_type is not None:
      oprot.writeFieldBegin('snap_type', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.snap_type))
      for iter57 in self.snap_type:
        oprot.writeI32(iter57)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snap_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetDetTasks_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetDetTasks_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDetTasks_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDetTasks_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDetTasks_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype61, _size58) = iprot.readListBegin()
          for _i62 in xrange(_size58):
            _elem63 = iprot.readI32()
            self.success.append(_elem63)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDetTasks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter64 in self.success:
        oprot.writeI32(iter64)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSnapProps_args:
  """
  Attributes:
   - snap_props
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'snap_props', (RpcSnapProps, RpcSnapProps.thrift_spec), None, ), # 1
  )

  def __init__(self, snap_props=None,):
    self.snap_props = snap_props

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.snap_props = RpcSnapProps()
          self.snap_props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSnapProps_args')
    if self.snap_props is not None:
      oprot.writeFieldBegin('snap_props', TType.STRUCT, 1)
      self.snap_props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snap_props)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSnapProps_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSnapProps_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSnapProps_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSnapProps_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSnapProps_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcSnapProps, RpcSnapProps.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcSnapProps()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSnapProps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSnapConnectionInfo_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSnapConnectionInfo_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSnapConnectionInfo_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcSnapConnectInfo, RpcSnapConnectInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcSnapConnectInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSnapConnectionInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSnapPublicKey_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSnapPublicKey_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSnapPublicKey_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSnapPublicKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResetSnapPriveteKey_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResetSnapPriveteKey_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResetSnapPriveteKey_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResetSnapPriveteKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetCompatible_args:
  """
  Attributes:
   - compatible
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'compatible', None, None, ), # 1
  )

  def __init__(self, compatible=None,):
    self.compatible = compatible

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.compatible = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetCompatible_args')
    if self.compatible is not None:
      oprot.writeFieldBegin('compatible', TType.BOOL, 1)
      oprot.writeBool(self.compatible)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.compatible)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetCompatible_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetCompatible_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCompatible_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCompatible_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCompatible_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCompatible_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetImgTransProperties_args:
  """
  Attributes:
   - snap_type
   - img_trans_prop
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'snap_type', None, None, ), # 1
    (2, TType.STRUCT, 'img_trans_prop', (RpcImgTransProperties, RpcImgTransProperties.thrift_spec), None, ), # 2
  )

  def __init__(self, snap_type=None, img_trans_prop=None,):
    self.snap_type = snap_type
    self.img_trans_prop = img_trans_prop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.snap_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.img_trans_prop = RpcImgTransProperties()
          self.img_trans_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetImgTransProperties_args')
    if self.snap_type is not None:
      oprot.writeFieldBegin('snap_type', TType.I32, 1)
      oprot.writeI32(self.snap_type)
      oprot.writeFieldEnd()
    if self.img_trans_prop is not None:
      oprot.writeFieldBegin('img_trans_prop', TType.STRUCT, 2)
      self.img_trans_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snap_type)
    value = (value * 31) ^ hash(self.img_trans_prop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetImgTransProperties_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetImgTransProperties_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetImgTransProperties_args:
  """
  Attributes:
   - snap_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'snap_type', None, None, ), # 1
  )

  def __init__(self, snap_type=None,):
    self.snap_type = snap_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.snap_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetImgTransProperties_args')
    if self.snap_type is not None:
      oprot.writeFieldBegin('snap_type', TType.I32, 1)
      oprot.writeI32(self.snap_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snap_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetImgTransProperties_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RpcImgTransProperties, RpcImgTransProperties.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RpcImgTransProperties()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetImgTransProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetImgTransList_args:
  """
  Attributes:
   - snap_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'snap_type', (TType.I32,None), None, ), # 1
  )

  def __init__(self, snap_type=None,):
    self.snap_type = snap_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.snap_type = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = iprot.readI32()
            self.snap_type.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetImgTransList_args')
    if self.snap_type is not None:
      oprot.writeFieldBegin('snap_type', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.snap_type))
      for iter71 in self.snap_type:
        oprot.writeI32(iter71)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snap_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetImgTransList_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetImgTransList_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetImgTransList_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetImgTransList_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetImgTransList_result:
  """
  Attributes:
   - success
   - excpt
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, excpt=None,):
    self.success = success
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = iprot.readI32()
            self.success.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetImgTransList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter78 in self.success:
        oprot.writeI32(iter78)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SaveParam_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SaveParam_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SaveParam_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SaveParam_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LoadParam_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LoadParam_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LoadParam_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LoadParam_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StartLibraF_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartLibraF_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StartLibraF_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartLibraF_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StopLibraF_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StopLibraF_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StopLibraF_result:
  """
  Attributes:
   - excpt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'excpt', (RpcLibraFException, RpcLibraFException.thrift_spec), None, ), # 1
  )

  def __init__(self, excpt=None,):
    self.excpt = excpt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.excpt = RpcLibraFException()
          self.excpt.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StopLibraF_result')
    if self.excpt is not None:
      oprot.writeFieldBegin('excpt', TType.STRUCT, 1)
      self.excpt.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.excpt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
